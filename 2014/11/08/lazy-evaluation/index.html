<!DOCTYPE HTML>

<!--[if false]>
少年，不得不说，这是缘分。简历快到碗里来，贴吧欢迎你 liuwayong@gmail.com :)  

                                            `--.       `                                             
                                          :hddhs.  .+yhs/`                                          
                                         .yddddd+ -yddddd+                                          
                                     ``  .yddddd+ +ddddddo`                                         
                                   .+yys:`:yhhhs. :hdddhs. `                                        
                                  `yddddd+``--.    .://-.+sss+.                                     
                                  :ddddddy.   `---.`   `sdddddy-                                    
 -/////////:-.               `://.`shdddh+  -oyhhhhs/` .ydddddh/`-------. .--```  `------.--------` 
 /hhyyssssyyyy/`             `oss: `:++/-``/hhhhddddhs-`oddddds..yyooosy+`+hyooo- :yysshh+yyoyysyy/ 
 /hhs.````./yhy- -:::::::-.  `///-      ./yddy.-hdddddho::+++:` .hh-o+:h+`+hs---` :yy--hh+hy.yy:oh/ 
 /hhy/:::::oyho. :ooooooyyyo.`shy/    -oyyo/+: .y++hdy+oyo:`    .hh-hs:h+.ohs-..` :yy--hh+hy.yy:oh/ 
 /hhhyyyyyyhhy:`  .-----:shy/`shy/  `+hdo``+o/ .o``yds .ydhy-   .hh-hs:h+oyyssyy+ :yy--hh+hy-yy/sh/ 
 /hhs-...../yhy/.oyysssssyhy/`shy/  :hdh: :dds .o``yds .ydddy.  .hh-hs:h+sho``yh+ :yy--hh+hhssssss: 
 /hhs-....-/yhho/hhs-```.shy/`shy/  -hdds-`-:- .s.`.:- .ydddy.  `/+ohho+-sho  yh+ :yy::hh+hy``````  
 /hhhyyyyyyhyyo..syyyssssyyy/`syy/   :yddhyssssshhsssssyhddy:    /oy+oyo:shyooyh+ -yyssyo/yhoooooo: 
 .----------.`    .---------` .--`    `-/////:-....-/+ooo+:`     --- `--..------`         .-------. <![endif]-->
<html>
<head>
  <meta charset="utf-8">
  
  <title>延迟求值-如何让Lo-Dash再提速x100? | 刘哇勇的部落格</title>
  <meta name="author" content="wayou">
  
  <meta name="description" content="「注释」作者在本文里没有说明这么一个事实：目前的版本Lo-Dash v2.4.1并没有引入延迟求值的特性，Lo-Dash 3.0.0-pre中部分方法进行了引入，比如filter(),map(),reverse()。
原文：How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation

我时常觉得像Lo-Dash这样优秀的库已经无法再优化了。它整合了各种奇技淫巧已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="延迟求值-如何让Lo-Dash再提速x100?"/>
  <meta property="og:site_name" content="刘哇勇的部落格"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  <!-- toc -->
  <link rel="stylesheet" href="/css/jquery.tocify.css" media="screen" type="text/css">
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <!-- material design -->
  <link rel="stylesheet" href="/material/css/ripples.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/material/css/material.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

</head>



 <body >  
  <nav id="main-nav" class="navbar navbar-default" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">刘哇勇的部落格</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav navbar-right">
		  
		  <li>
			<a  href="/" >
			  <i class="fa fa-home"></i>首页
			</a>
		  </li>
		  
		  <li>
			<a  href="/archives" >
			  <i class="fa fa-list"></i>存档
			</a>
		  </li>
		  
		  <li>
			<a  href="/about" >
			  <i class="fa fa-info-circle"></i>关于
			</a>
		  </li>
		  
		  <li>
			<a  href="/atom.xml" >
			  <i class="fa fa-rss"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container" >
  	<div class="content">
    	 


	
		<div class="page-header">		
			<h1>
			
			
			  延迟求值-如何让Lo-Dash再提速x100?
			
			</h1>
		</div>		
	



<div class="row post">
	<!-- cols -->
	
	<div class="col-md-9">
	

			

	<!-- content -->
	<div class="mypage">
		<div class="row widget-wrapper">
			<!-- date -->
			
			<div class="post-meta-item">
				<i class="fa fa-clock-o"></i>
				<span class="post-time">2014-11-8 15:29:27</span>
			</div>
			

			<!-- author -->
			
			<div class="post-meta-item">
				<i class="fa fa-user" title="author"></i>
				<span >wayou</span>
			</div>
			

			<!-- categories -->
		    
			<div class="post-meta-item">
				<i class="fa fa-folder"></i>
				
				<a class="label label-success" href="/categories/技术/">技术</a>
			</div>
			

			<!-- tags -->
			
			<div class="post-meta-item">
				<i class="fa fa-tags"></i>
				
				<a class="label label-warning" href="/tags/JavaScript/">JavaScript</a> <a class="label label-warning" href="/tags/性能/">性能</a>
			</div>
			
		</div>


	    <blockquote>
<p>「注释」作者在本文里没有说明这么一个事实：<br>目前的版本<code>Lo-Dash v2.4.1</code>并没有引入延迟求值的特性，<code>Lo-Dash 3.0.0-pre</code>中部分方法进行了引入，比如<code>filter()</code>,<code>map()</code>,<code>reverse()</code>。</p>
<p>原文：<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation" target="_blank" rel="external">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a></p>
</blockquote>
<p>我时常觉得像<code>Lo-Dash</code>这样优秀的库已经无法再优化了。它整合了各种<a href="https://www.youtube.com/watch?v=NthmeLEhDDM" target="_blank" rel="external">奇技淫巧</a>已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。</p>
<a id="more"></a>

<h1 id="延迟求值">延迟求值</h1>
<p>但似乎我错了-还可以让<code>Lo-Dash</code>有明显的提升。只需将关注点从细微的优化转移到算法上来。譬如，在一次循环中我们往往会去优化循环体：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> len = getLength();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {</div><div class="line">    operation(); <span class="comment">// &lt;- 10ms - 如何做到 9ms?!</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但针对循环体的优化往往很难，很多时候已经到极限了。相反，优化<code>getLength()</code> 函数尽量减少循环次数变得更有意义了。你想啊，这个数值越小，需要循环的<code>10ms</code>就越少。</p>
<p>这便是<code>Lo-Dash</code>实现延迟求值的大致思路。重要的是减少循环次数，而不是每次循环的时间。让我们考察下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">priceLt</span><span class="params">(x)</span> </span>{</div><div class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>{ <span class="keyword">return</span> item.price &lt; x; };</div><div class="line">}</div><div class="line"><span class="keyword">var</span> gems = [</div><div class="line">   { name: <span class="string">'Sunstone'</span>, price: <span class="number">4</span> }, { name: <span class="string">'Amethyst'</span>, price: <span class="number">15</span> },</div><div class="line">   { name: <span class="string">'Prehnite'</span>, price: <span class="number">20</span>}, { name: <span class="string">'Sugilite'</span>, price: <span class="number">7</span>  },</div><div class="line">   { name: <span class="string">'Diopside'</span>, price: <span class="number">3</span> }, { name: <span class="string">'Feldspar'</span>, price: <span class="number">13</span> },</div><div class="line">   { name: <span class="string">'Dioptase'</span>, price: <span class="number">2</span> }, { name: <span class="string">'Sapphire'</span>, price: <span class="number">20</span> }</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> chosen = _(gems).filter(priceLt(<span class="number">10</span>)).take(<span class="number">3</span>).value();</div></pre></td></tr></table></figure>

<p>我们只想取出3个价格低于10元的小球。通常情况下我们先过滤整个数据源，最后从所有小于10的元素里返回前面三个即可。</p>
<p><img src="/asset/posts/2014-11-08-lazy-evaluation/lodash-naive.gif" alt="lo-dash naive"></p>
<p>但这种做法并不优雅。它处理了全部8个数据，但其实只需要处理前面5个我们就能拿到结果了。同样为了得到正确的结果，延迟求值则只处理最少的元素。优化后如下图所示：</p>
<p><img src="/asset/posts/2014-11-08-lazy-evaluation/grafika.gif" alt="lo-dash naive"></p>
<p>一下子就获得了37.5%的性能提升。很容易找出提升X1000+的例子。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> phoneNumbers = [<span class="number">5554445555</span>, <span class="number">1424445656</span>, <span class="number">5554443333</span>, … ×<span class="number">99</span>,<span class="number">999</span>];</div><div class="line"></div><div class="line"><span class="comment">// 取出100个含 `55` 的号码</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains55</span><span class="params">(str)</span> </span>{</div><div class="line">    <span class="keyword">return</span> str.contains(<span class="string">"55"</span>); </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> r = _(phoneNumbers).map(<span class="built_in">String</span>).filter(contains55).take(<span class="number">100</span>);</div></pre></td></tr></table></figure>

<p>这个例子中<code>map</code>和<code>filter</code> 将遍历99999 个元素，但很有可能我们只需处理到1000个元素的时候就已经拿到想要的结果了。这回性能的提升就太明显了（<a href="http://jsperf.com/lazy-demo" target="_blank" rel="external">benchmark</a>）：</p>
<p><img src="/asset/posts/2014-11-08-lazy-evaluation/benchmark.jpg" alt="benchmark"></p>
<h1 id="流水线">流水线</h1>
<p>延迟求值同时带来了另一个好处，我称之为“流水线”。要旨就是避免产生中间数组，而是对一个元素一次性进行完所有操作。下面用代码说话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = _(source).map(func1).map(func2).map(func3).value();</div></pre></td></tr></table></figure>

<p>上面看似优雅的写法在原始的<code>Lo-Dash</code>里会转换成下面的样子（直接求值）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [], temp1 = [], temp2 = [], temp3 = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp1[i] = func1(source[i]);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp2[i] = func2(temp1[i]);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp3[i] = func3(temp2[i]);</div><div class="line">}</div><div class="line">result = temp3;</div></pre></td></tr></table></figure>

<p>当引入了延迟求值后，代码大致就成这样的了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   result[i] = func3(func2(func1(source[i])));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>减少不必要的中间变量多少会带来性能上的提升，特别是在数据源特别巨大，内存又吃紧的情况下。</p>
<h1 id="延迟执行">延迟执行</h1>
<p>延迟求值带来的另一个好处是延迟执行。无论何时你写了段链式代码，只有在显式地调用了<code>.value()</code>后才会真正执行。这样一来，在数据源需要异步去拉取的情况下，可以保证我们处理的是最新的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wallet = _(assets).filter(ownedBy(<span class="string">'me'</span>))</div><div class="line">                      .pluck(<span class="string">'value'</span>)</div><div class="line">                      .reduce(sum);</div><div class="line"></div><div class="line">$json.get(<span class="string">"/new/assets"</span>).success(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{</div><div class="line">    assets.push.apply(assets, data); <span class="comment">// 更新数据源</span></div><div class="line">    wallet.value(); <span class="comment">// 返回的结果是最新的</span></div><div class="line">});</div></pre></td></tr></table></figure>

<p>而且这种机制在某些情况下也会提高执行效果。我们可以老早发送一个请求获取数据，然后指定一个精确的时间来执行。</p>
<h1 id="后记">后记</h1>
<p>延迟求值并且不算什么新技术。在一些库中已经在使用了，比如<a href="http://en.wikipedia.org/wiki/Language_Integrated_Query" target="_blank" rel="external">LINQ</a>,<a href="http://danieltao.com/lazy.js/" target="_blank" rel="external">Lazy.js</a>还有其他等等。那么问题来了，<code>Lo-Dash</code>存在的意义是啥？我想就是你仍然可以使用你熟悉的<code>Underscore</code> 接口但享受一个更高效的底层实现，不需要额外的学习成本，代码上面也不会有大的变动，只需稍加修改。</p>
	 
	</div>

	<div>
  	<center>
	<div class="pagination-wrapper">
 
       
      <a class="btn btn-default" href="/2014/11/26/javascript-benchmarking/" class="alignleft prev"><i class="fa fa-chevron-left"></i>上一篇</a>
      

        <a class="btn btn-default" href="/"><i class="fa fa-home"></i>首页</a>

    
       <a class="btn btn-default" href="/2014/11/02/how-to-make-a-simple-html5-canvas-game-zh/" class="alignright next">下一篇<i class="fa fa-chevron-right"></i></a>   
        
  
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
  <!--<h2 class="title">留言</h2>-->

  
   <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="_posts/2014-11-08-lazy-evaluation.md" data-title="延迟求值-如何让Lo-Dash再提速x100?" data-url="http://wayou.github.io/2014/11/08/lazy-evaluation/"></div>
    <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'wayouliu'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  
</section>


	
	</div> <!-- col-md-9/col-md-12 -->
	
	
		<div class="col-md-3"> 

	<!-- date -->
	<!--
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2014-11-8 
	</div>
	-->

	<!-- categories -->
   <!-- 
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/技术/">技术</a></li>
  </li>

    </ul>
	</div>
	-->

	<!-- tags -->
	<!--
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/JavaScript/">JavaScript</a></li> <li><a href="/tags/性能/">性能</a></li>
    </ul>
	</div>
		-->

	<!-- toc -->
	
		<div id="toc" ></div>
		
</div><!-- col-md-3 -->




	

</div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>&copy; 2015 
<i class="mdi-hardware-keyboard-arrow-left" style="font-size: 10pt;"></i>/<i class="mdi-hardware-keyboard-arrow-right" style="font-size: 10pt;"></i> with <i class="mdi-action-favorite icon-material-red" style="font-size: 10pt;"></i>

by <a href="http://wayou.github.io">wayou</a>
  
 | 由<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>强力驱动
</p>
 </footer>
</div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <i class="fa fa-chevron-circle-up"></i>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<!-- material design -->
<script src="/material/js/ripples.js"></script>
<script src="/material/js/material.js"></script>
<!-- toc -->
<script src="/js/jqueryui.js"></script>
<script src="/js/jquery.tocify.js"></script>

<!-- make the embeded video responsive -->
<script src="/js/jquery.fitvids.js"></script>

<script src="/js/main.js"></script>

<!-- analytics -->

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-46794744-6']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;

ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';

var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
 






</body>
</html>
