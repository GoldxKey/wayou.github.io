<html lang="en"><head><meta charset="utf-8"><title>延迟求值-如何让Lo-Dash再提速x100? | 刘哇勇的部落格</title><meta content="width=device-width,initial-scale=1,maximum-scale=1" name="viewport"><meta name="theme-color" content="undefined"><link href="/favicon.ico" rel="icon"><link rel="stylesheet" href="/css/highlight.light.css"><link rel="stylesheet" href="/css/preloader.css"><link rel="stylesheet" href="/css/nav-icon.css"><link rel="stylesheet" href="/css/waves.min.css"><link rel="stylesheet" href="/css/jquery.tocify.css"><link rel="stylesheet" href="/css/smooth-state-anim.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/nav-indicator.css"><style type="text/css">a{color:#3c80f6}.menu-wrapper a,nav a{color:#fff}.material-hamburger span{background:#fff}.nav-toggle-icon:before,.nav-wrapper{background-color:#4184f3}article{color:#000}</style></head><body><header><div aria-busy="true" aria-label="Loading, please wait." class="material-preloader" role="progressbar"></div></header><div id="main" class="m-scene"><div class="nav-wrapper" style="background-color:undefined"><div class="container"><nav><div class="logo wave"><a href="/" id="logo">刘哇勇的部落格</a></div><div class="nav-toggle-icon"><div class="material-hamburger"><span></span> <span></span> <span></span></div></div><div class="menu-wrapper"><div class="nav-indicator"></div><ul class="menus"><li><a class="wave" href="/">首页</a></li><li><a class="wave" href="/archives">归档</a></li><li><a class="wave" href="/about">关于</a></li><li><a class="wave no-smoothstate" href="/atom.xml">订阅</a></li></ul></div></nav></div></div><div class="container content"><div class="scene_element scene_element--fadein"><div class="row"><div class="main"><article><header class="post-header"><h1 class="post-title">延迟求值-如何让Lo-Dash再提速x100?</h1></header><section class="post-info"><span class="post-date">2014/11/8</span> <span class="post-category"><a class="article-category-link" href="/categories/技术/">技术</a> </span><span class="post-tags"><ul class="post-tag-list"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/性能/">性能</a></li></ul></span></section><section class="post-content"><p><em>作者在本文里没有说明这么一个事实：<br>目前的版本<code>Lo-Dash v2.4.1</code>并没有引入延迟求值的特性，<code>Lo-Dash 3.0.0-pre</code>中部分方法进行了引入，比如<code>filter()</code>,<code>map()</code>,<code>reverse()</code>。</em></p><blockquote><p>原文：<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation" target="_blank" rel="external">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a></p></blockquote><p>我时常觉得像<code>Lo-Dash</code>这样优秀的库已经无法再优化了。它整合了各种<a href="https://www.youtube.com/watch?v=NthmeLEhDDM" target="_blank" rel="external">奇技淫巧</a>已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。</p><a id="more"></a><h2 id="u5EF6_u8FDF_u6C42_u503C"><a href="/2014/11/08/lazy-evaluation/#u5EF6_u8FDF_u6C42_u503C" class="headerlink" title="延迟求值"></a>延迟求值</h2><p>但似乎我错了-还可以让<code>Lo-Dash</code>有明显的提升。只需将关注点从细微的优化转移到算法上来。譬如，在一次循环中我们往往会去优化循环体：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> len = getLength();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    operation(); <span class="comment">// &lt;- 10ms - 如何做到 9ms?!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但针对循环体的优化往往很难，很多时候已经到极限了。相反，优化<code>getLength()</code> 函数尽量减少循环次数变得更有意义了。你想啊，这个数值越小，需要循环的<code>10ms</code>就越少。</p><p>这便是<code>Lo-Dash</code>实现延迟求值的大致思路。重要的是减少循环次数，而不是每次循环的时间。让我们考察下面的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">priceLt</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123; <span class="keyword">return</span> item.price &lt; x; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gems = [</span><br><span class="line">   &#123; name: <span class="string">'Sunstone'</span>, price: <span class="number">4</span> &#125;, &#123; name: <span class="string">'Amethyst'</span>, price: <span class="number">15</span> &#125;,</span><br><span class="line">   &#123; name: <span class="string">'Prehnite'</span>, price: <span class="number">20</span>&#125;, &#123; name: <span class="string">'Sugilite'</span>, price: <span class="number">7</span>  &#125;,</span><br><span class="line">   &#123; name: <span class="string">'Diopside'</span>, price: <span class="number">3</span> &#125;, &#123; name: <span class="string">'Feldspar'</span>, price: <span class="number">13</span> &#125;,</span><br><span class="line">   &#123; name: <span class="string">'Dioptase'</span>, price: <span class="number">2</span> &#125;, &#123; name: <span class="string">'Sapphire'</span>, price: <span class="number">20</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chosen = _(gems).filter(priceLt(<span class="number">10</span>)).take(<span class="number">3</span>).value();</span><br></pre></td></tr></table></figure><p>我们只想取出3个价格低于10元的小球。通常情况下我们先过滤整个数据源，最后从所有小于10的元素里返回前面三个即可。</p><p><img src="/2014/11/08/lazy-evaluation/lodash-naive.gif" alt="lo-dash naive"><span class="image-caption">lo-dash naive</span></p><p>但这种做法并不优雅。它处理了全部8个数据，但其实只需要处理前面5个我们就能拿到结果了。同样为了得到正确的结果，延迟求值则只处理最少的元素。优化后如下图所示：</p><p><img src="/2014/11/08/lazy-evaluation/grafika.gif" alt="lo-dash naive"><span class="image-caption">lo-dash naive</span></p><p>一下子就获得了37.5%的性能提升。很容易找出提升X1000+的例子。比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> phoneNumbers = [<span class="number">5554445555</span>, <span class="number">1424445656</span>, <span class="number">5554443333</span>, … ×<span class="number">99</span>,<span class="number">999</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出100个含 `55` 的号码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains55</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.contains(<span class="string">"55"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = _(phoneNumbers).map(<span class="built_in">String</span>).filter(contains55).take(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这个例子中<code>map</code>和<code>filter</code> 将遍历99999 个元素，但很有可能我们只需处理到1000个元素的时候就已经拿到想要的结果了。这回性能的提升就太明显了（<a href="http://jsperf.com/lazy-demo" target="_blank" rel="external">benchmark</a>）：</p><p><img src="/2014/11/08/lazy-evaluation/benchmark.jpg" alt="benchmark"><span class="image-caption">benchmark</span></p><h2 id="u6D41_u6C34_u7EBF"><a href="/2014/11/08/lazy-evaluation/#u6D41_u6C34_u7EBF" class="headerlink" title="流水线"></a>流水线</h2><p>延迟求值同时带来了另一个好处，我称之为“流水线”。要旨就是避免产生中间数组，而是对一个元素一次性进行完所有操作。下面用代码说话：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = _(source).map(func1).map(func2).map(func3).value();</span><br></pre></td></tr></table></figure><p>上面看似优雅的写法在原始的<code>Lo-Dash</code>里会转换成下面的样子（直接求值）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [], temp1 = [], temp2 = [], temp3 = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">   temp1[i] = func1(source[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">   temp2[i] = func2(temp1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">   temp3[i] = func3(temp2[i]);</span><br><span class="line">&#125;</span><br><span class="line">result = temp3;</span><br></pre></td></tr></table></figure><p>当引入了延迟求值后，代码大致就成这样的了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">   result[i] = func3(func2(func1(source[i])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少不必要的中间变量多少会带来性能上的提升，特别是在数据源特别巨大，内存又吃紧的情况下。</p><h2 id="u5EF6_u8FDF_u6267_u884C"><a href="/2014/11/08/lazy-evaluation/#u5EF6_u8FDF_u6267_u884C" class="headerlink" title="延迟执行"></a>延迟执行</h2><p>延迟求值带来的另一个好处是延迟执行。无论何时你写了段链式代码，只有在显式地调用了<code>.value()</code>后才会真正执行。这样一来，在数据源需要异步去拉取的情况下，可以保证我们处理的是最新的数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wallet = _(assets).filter(ownedBy(<span class="string">'me'</span>))</span><br><span class="line">                      .pluck(<span class="string">'value'</span>)</span><br><span class="line">                      .reduce(sum);</span><br><span class="line"></span><br><span class="line">$json.get(<span class="string">"/new/assets"</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    assets.push.apply(assets, data); <span class="comment">// 更新数据源</span></span><br><span class="line">    wallet.value(); <span class="comment">// 返回的结果是最新的</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而且这种机制在某些情况下也会提高执行效果。我们可以老早发送一个请求获取数据，然后指定一个精确的时间来执行。</p><h2 id="u540E_u8BB0"><a href="/2014/11/08/lazy-evaluation/#u540E_u8BB0" class="headerlink" title="后记"></a>后记</h2><p>延迟求值并且不算什么新技术。在一些库中已经在使用了，比如<a href="http://en.wikipedia.org/wiki/Language_Integrated_Query" target="_blank" rel="external">LINQ</a>,<a href="http://danieltao.com/lazy.js/" target="_blank" rel="external">Lazy.js</a>还有其他等等。那么问题来了，<code>Lo-Dash</code>存在的意义是啥？我想就是你仍然可以使用你熟悉的<code>Underscore</code> 接口但享受一个更高效的底层实现，不需要额外的学习成本，代码上面也不会有大的变动，只需稍加修改。</p></section></article><div class="pager"><a class="post-prev pager-item" href="/2014/11/26/javascript-benchmarking/"><strong class="article-nav-caption">上一篇</strong><p class="post-nav-title">JavaScript的基准测试-不服跑个分？</p></a><a class="post-next pager-item" href="/2014/11/02/how-to-make-a-simple-html5-canvas-game-zh/"><strong class="article-nav-caption">下一篇</strong><p class="post-nav-title">如何开发一个简单的HTML5 Canvas 小游戏</p></a></div><div class="comment-section"><div id="disqus_thread"></div><script>var disqus_shortname="wayouliu";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></div></div><aside><div id="toc"></div></aside></div></div></div></div><footer><p>由 <a href="http://hexo.io/" target="_blank">Hexo </a>强力驱动，搭载 <a href="#">gstyle </a>主题</p><p>&copy; 2016 Wayou Liu</p></footer><script src="/lib/jquery.js"></script><script src="/lib/jquery.smoothState.js"></script><script src="/lib/waves.js"></script><script src="/lib/jquery-ui.js"></script><script src="/lib/jquery.tocify.min.js"></script><script src="/js/main.js"></script></body></html>