<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[刘哇勇的部落格]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://wayou.github.io//"/>
  <updated>2015-07-06T11:15:41.000Z</updated>
  <id>http://wayou.github.io//</id>
  
  <author>
    <name><![CDATA[Wayou Liu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Angular条件路由]]></title>
    <link href="http://wayou.github.io/2015/03/08/redirect-before-routing-in-angular/"/>
    <id>http://wayou.github.io/2015/03/08/redirect-before-routing-in-angular/</id>
    <published>2015-03-08T11:43:04.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<p>对于Web程序通常会有这样的需求：针对不同的情况，我们希望用户进入站点后打开不同的页面。<br>写一下Web程序的时候，会有这样的需求：根据用户的类型，将用户导向不同的页面。<br>譬如，对于非注册用户，打开站点后导向到注册页面;<br>或者，以之前做的一个项目为例，对于普通用户，打开培训页面，而培训合格的用户，我们希望默认打开管理页面。</p>
<p>这样的路由控制当然可以由后端来做。</p>
<a id="more"></a>
<p>当使用了Angular这样的前端框架时，路由由前端控制并且是事先配好的（当然，这种情况下也不是说后端就不能控制路由了）。<br>一个典型的angular示例如下面代码所示：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'myApp'</span>, []);</span><br><span class="line"></span><br><span class="line">app.config([<span class="string">'$routeProvider'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">$routeProvider</span>) </span>&#123;</span><br><span class="line">        $routeProvider.</span><br><span class="line">        <span class="comment">//培训页面</span></span><br><span class="line">        when(<span class="string">'/home'</span>, &#123;</span><br><span class="line">            templateUrl: <span class="string">'views/home.html'</span>,</span><br><span class="line">            controller: <span class="string">'HomeCtrl'</span></span><br><span class="line">        &#125;).</span><br><span class="line">        <span class="comment">//管理</span></span><br><span class="line">        when(<span class="string">'/auth'</span>, &#123;</span><br><span class="line">            templateUrl: <span class="string">'views/auth.html'</span>,</span><br><span class="line">            controller: <span class="string">'AuthCtrl'</span></span><br><span class="line">        &#125;).</span><br><span class="line">        otherwise(&#123;</span><br><span class="line">            redirectTo: <span class="string">'/'</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p>
<p>这里不深入讨论完整的权限控制，用户当然可以手动更改URL来打开管理页面，但你可以选择不展示内容而是给个提示“无权限”之类的，总之这里不讨论，这里要说的就是我们有能力根据条件更改Angular路由的默认页面。</p>
<p>如果我们不做作何处理，根据现在的配置，默认是打开培训页面。为了对已经通过培训的用户默认打开管理页面，首先我们要知道当前用户的身份，然后判断是否该跳转。</p>
<p>Angular模块的<code>run</code>函数，是最接近主程序启动的地方，可以在这里进行判断与重定向。<br>所以更新后的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'myApp'</span>, []);</span><br><span class="line"></span><br><span class="line">app.config([<span class="string">'$routeProvider'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">$routeProvider</span>) </span>&#123;</span><br><span class="line">        $routeProvider.</span><br><span class="line">        <span class="comment">//首页</span></span><br><span class="line">        when(<span class="string">'/home'</span>, &#123;</span><br><span class="line">            templateUrl: <span class="string">'views/home.html'</span>,</span><br><span class="line">            controller: <span class="string">'HomeCtrl'</span></span><br><span class="line">        &#125;).</span><br><span class="line">        <span class="comment">//注册页</span></span><br><span class="line">        when(<span class="string">'/auth'</span>, &#123;</span><br><span class="line">            templateUrl: <span class="string">'views/auth.html'</span>,</span><br><span class="line">            controller: <span class="string">'AuthCtrl'</span></span><br><span class="line">        &#125;).</span><br><span class="line">        otherwise(&#123;</span><br><span class="line">            redirectTo: <span class="string">'/'</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">]).run([<span class="string">'$location'</span>, <span class="string">'$http'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">$location, $http</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        $http.get(<span class="string">'path/to/get/user/data'</span>).</span><br><span class="line">        success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//拿到用户数据，判断用户类型，然后定位到相应的页面</span></span><br><span class="line">            <span class="keyword">if</span> (res.member) &#123;</span><br><span class="line">                <span class="comment">//如果是合格用户，转向管理页面</span></span><br><span class="line">                $location.path(<span class="string">'/auth'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).</span><br><span class="line">        error(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>向模块添加<code>run</code>函数，首先发起一个请求获取用户数据，根据返回的数据进行判断，然后使用<code>$location.path</code>来重新路由。</p>
<h1 id="references">references</h1><ul>
<li><a href="https://docs.angularjs.org/guide/module" target="_blank" rel="external">Angular Modeule Run Blocks</a> </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于Web程序通常会有这样的需求：针对不同的情况，我们希望用户进入站点后打开不同的页面。<br>写一下Web程序的时候，会有这样的需求：根据用户的类型，将用户导向不同的页面。<br>譬如，对于非注册用户，打开站点后导向到注册页面;<br>或者，以之前做的一个项目为例，对于普通用户，打开培训页面，而培训合格的用户，我们希望默认打开管理页面。</p>
<p>这样的路由控制当然可以由后端来做。</p>]]>
    
    </summary>
    
      <category term="anular" scheme="http://wayou.github.io/tags/anular/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解this]]></title>
    <link href="http://wayou.github.io/2015/01/18/all-this/"/>
    <id>http://wayou.github.io/2015/01/18/all-this/</id>
    <published>2015-01-18T20:47:24.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<p><code>this</code> 虐我千百遍，看完此文效立见！不得不说，这篇文章的总结很地道很全面，适合收藏之用。</p>
<blockquote>
<p>原文：<a href="http://bjorn.tipling.com/all-this" target="_blank" rel="external">all this</a></p>
</blockquote>
<p>习惯了高级语言的你或许觉得JavaScript中的<code>this</code>跟Java这些面向对象语言相似，保存了实体属性的一些值。其实不然。将它视作<a href="http://harrypotter.wikia.com/wiki/Boggart" target="_blank" rel="external">幻影魔神</a>比较恰当，手提一个装满未知符文的<a href="http://harrypotter.wikia.com/wiki/Undetectable_Extension_Charm" target="_blank" rel="external">灵龛</a>。</p>
<p>以下内容我希望广大同行们能够了解。全是掏箱底的干货，其中大部分占用了我很多时间才掌握。</p>
<a id="more"></a>
<h1 id="全局this">全局<code>this</code></h1><p>浏览器宿主的全局环境中，<code>this</code>指的是<code>window</code>对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="coffeescript"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="regexp">//</span><span class="literal">true</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/hL9emz4m/" target="_blank" rel="external">示例</a></p>
<p>浏览器中在全局环境下，使用<code>var</code>声明变量其实就是赋值给<code>this</code>或<code>window</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="coffeescript"></span><br><span class="line">    <span class="reserved">var</span> foo = <span class="string">"bar"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="regexp">//</span>logs <span class="string">"bar"</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.foo); <span class="regexp">//</span>logs <span class="string">"bar"</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/1/" target="_blank" rel="external">示例</a></p>
<p>任何情况下，创建变量时没有使用<code>var</code>或者<code>let</code>(ECMAScript 6)，也是在操作全局<code>this</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="openscad"></span><br><span class="line">    foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testThis</span><span class="params">()</span> &#123;</span></span><br><span class="line">      foo = <span class="string">"foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.<span class="built_in">log</span><span class="params">(this.foo)</span>; <span class="comment">//logs "bar"</span></span><br><span class="line">    testThis<span class="params">()</span>;</span><br><span class="line">    console.<span class="built_in">log</span><span class="params">(this.foo)</span>; <span class="comment">//logs "foo"</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/3/" target="_blank" rel="external">示例</a></p>
<p>Node命令行（REPL）中，<code>this</code>是全局命名空间。可以通过<code>global</code>来访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; this</span><br><span class="line">&#123; ArrayBuffer: [Function: ArrayBuffer],</span><br><span class="line">  Int8Array: &#123; [Function: Int8Array] BYTES_PER_ELEMENT: <span class="number">1</span> &#125;,</span><br><span class="line">  Uint8Array: &#123; [Function: Uint8Array] BYTES_PER_ELEMENT: <span class="number">1</span> &#125;,</span><br><span class="line">  ...</span><br><span class="line">&gt; global === this</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>在Node环境里执行的JS脚本中，<code>this</code>其实是个空对象，有别于<code>global</code>。</p>
<figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === global);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当尝试在Node中执行JS脚本时，脚本中全局作用域中的<code>var</code>并不会将变量赋值给全局<code>this</code>，这与在浏览器中是不一样的。</p>
<figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">"bar"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
<p>…但在命令行里进行求值却会赋值到<code>this</code>身上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; var foo = <span class="string">"bar"</span>;</span><br><span class="line">&gt; this.foo</span><br><span class="line">bar</span><br><span class="line">&gt; global.foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>在Node里执行的脚本中，创建变量时没带<code>var</code>或<code>let</code>关键字，会赋值给全局的<code>global</code>但不是<code>this</code>（译注：上面已经提到<code>this</code>和<code>global</code>不是同一个对象，所以这里就不奇怪了）。</p>
<figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="code"><pre><span class="line">foo = <span class="string">"bar"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line"><span class="built_in">console</span>.log(global.foo);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">undefined</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>但在Node命令行里，就会赋值给两者了。</p>
<blockquote>
<p>译注：简单来说，Node脚本中<code>global</code>和<code>this</code>是区别对待的，而Node命令行中，两者可等效为同一对象。</p>
</blockquote>
<h1 id="函数或方法里的this">函数或方法里的<code>this</code></h1><p>除了DOM的事件回调或者提供了执行上下文（后面会提到）的情况，函数正常被调用（不带<code>new</code>）时，里面的<code>this</code>指向的是全局作用域。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></span><br><span class="line">    testThis();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "foo"</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/4/" target="_blank" rel="external">示例</a></p>
<figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="code"><pre><span class="line">foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testThis</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(global.foo);</span><br><span class="line">testThis();</span><br><span class="line"><span class="built_in">console</span>.log(global.foo);</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">bar</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>
<p>还有个例外，就是使用了<code>&quot;use strict&quot;;</code>。此时<code>this</code>是<code>undefined</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="pi">      "use strict"</span>;</span><br><span class="line">      <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></span><br><span class="line">    testThis();  <span class="comment">//Uncaught TypeError: Cannot set property 'foo' of undefined </span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/51/" target="_blank" rel="external">示例</a></p>
<p>当用调用函数时使用了<code>new</code>关键字，此刻<code>this</code>指代一个新的上下文，不再指向全局<code>this</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></span><br><span class="line">    <span class="keyword">new</span> testThis();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> testThis().foo); <span class="comment">//logs "foo"</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/6/" target="_blank" rel="external">示例</a></p>
<p>通常我将这个新的上下文称作实例。</p>
<h1 id="原型中的this">原型中的<code>this</code></h1><p>函数创建后其实以一个函数对象的形式存在着。既然是对象，则自动获得了一个叫做<code>prototype</code>的属性，可以自由地对这个属性进行赋值。当配合<code>new</code>关键字来调用一个函数创建实例后，此刻便能直接访问到原型身上的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing(); <span class="comment">//logs "bar"</span></span><br><span class="line"><span class="built_in">console</span>.log(thing.foo);  <span class="comment">//logs "bar"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/8/" target="_blank" rel="external">示例</a></p>
<p>当通过<code>new</code>的方式创建了多个实例后，他们会共用一个原型。比如，每个实例的<code>this.foo</code>都返回相同的值，直到<code>this.foo</code>被重写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.setFoo = <span class="function"><span class="keyword">function</span> (<span class="params">newFoo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = newFoo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing1 = <span class="keyword">new</span> Thing();</span><br><span class="line"><span class="keyword">var</span> thing2 = <span class="keyword">new</span> Thing();</span><br><span class="line"></span><br><span class="line">thing1.logFoo(); <span class="comment">//logs "bar"</span></span><br><span class="line">thing2.logFoo(); <span class="comment">//logs "bar"</span></span><br><span class="line"></span><br><span class="line">thing1.setFoo(<span class="string">"foo"</span>);</span><br><span class="line">thing1.logFoo(); <span class="comment">//logs "foo";</span></span><br><span class="line">thing2.logFoo(); <span class="comment">//logs "bar";</span></span><br><span class="line"></span><br><span class="line">thing2.foo = <span class="string">"foobar"</span>;</span><br><span class="line">thing1.logFoo(); <span class="comment">//logs "foo";</span></span><br><span class="line">thing2.logFoo(); <span class="comment">//logs "foobar";</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/9/" target="_blank" rel="external">示例</a></p>
<p>在实例中，<code>this</code>是个特殊的对象，而<code>this</code>自身其实只是个关键字。你可以把<code>this</code>想象成在实例中获取原型值的一种途径，同时对<code>this</code>赋值又会覆盖原型上的值。完全可以将新增的值从原型中删除从而将原型还原为初始状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.setFoo = <span class="function"><span class="keyword">function</span> (<span class="params">newFoo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = newFoo;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.deleteFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.setFoo(<span class="string">"foo"</span>);</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "foo";</span></span><br><span class="line">thing.deleteFoo();</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "bar";</span></span><br><span class="line">thing.foo = <span class="string">"foobar"</span>;</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "foobar";</span></span><br><span class="line"><span class="keyword">delete</span> thing.foo;</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "bar";</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/11/" target="_blank" rel="external">示例</a></p>
<p>…或者不通过实例，直接操作函数的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo, Thing.prototype.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.foo = <span class="string">"foo"</span>;</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "foo bar";</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/12/" target="_blank" rel="external">示例</a></p>
<p>同一函数创建的所有实例均共享一个原型。如果你给原型赋值了一个数组，那么所有实例都能获取到这个数组。除非你在某个实例中对其进行了重写，实事上是进行了覆盖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.things = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing1 = <span class="keyword">new</span> Thing();</span><br><span class="line"><span class="keyword">var</span> thing2 = <span class="keyword">new</span> Thing();</span><br><span class="line">thing1.things.push(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thing2.things); <span class="comment">//logs ["foo"]</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/13/" target="_blank" rel="external">示例</a></p>
<p>通常上面的做法是不正确的（译注：改变<code>thing1</code>的同时也影响了<code>thing2</code>）。如果你想每个实例互不影响，那么请在函数里创建这些值，而不是在原型上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.things = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing1 = <span class="keyword">new</span> Thing();</span><br><span class="line"><span class="keyword">var</span> thing2 = <span class="keyword">new</span> Thing();</span><br><span class="line">thing1.things.push(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(thing1.things); <span class="comment">//logs ["foo"]</span></span><br><span class="line"><span class="built_in">console</span>.log(thing2.things); <span class="comment">//logs []</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/14/" target="_blank" rel="external">示例</a></p>
<p>多个函数可以形成原型链，这样<code>this</code>便会在原型链上逐步往上找直到找到你想引用的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing1.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing2.prototype = <span class="keyword">new</span> Thing1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing2();</span><br><span class="line"><span class="built_in">console</span>.log(thing.foo); <span class="comment">//logs "bar"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/15/" target="_blank" rel="external">示例</a></p>
<p>很多人便是利用这个特性在JS中模拟经典的对象继承。</p>
<p>注意原型链底层函数中对<code>this</code>的操作会覆盖上层的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing1.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Thing2.prototype = <span class="keyword">new</span> Thing1();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing3.prototype = <span class="keyword">new</span> Thing2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing3();</span><br><span class="line"><span class="built_in">console</span>.log(thing.foo); <span class="comment">//logs "foo"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/16/" target="_blank" rel="external">示例</a></p>
<p>我习惯将赋值到原型上的函数称作方法。上面某些地方便使用了方法这样的字眼，比如<code>logFoo</code>方法。这些方法中的<code>this</code>同样具有在原型链上查找引用的魔力。通常将最初用来创建实例的函数称作构造函数。</p>
<p>原型链方法中的<code>this</code>是从实例中的<code>this</code>开始住上查找整个原型链的。也就是说，如果原型链中某个地方直接对<code>this</code>进行赋值覆盖了某个变量，那么我们拿到 的是覆盖后的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing1.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing1.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Thing2.prototype = <span class="keyword">new</span> Thing1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing2();</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "foo";</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/17/" target="_blank" rel="external">示例</a></p>
<p>在JavaScript中，函数可以嵌套函数，也就是你可以在函数里面继续定义函数。但内层函数是通过闭包获取外层函数里定义的变量值的，而不是直接继承<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> info = <span class="string">"attempting to log this.foo:"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(info, <span class="keyword">this</span>.foo);</span><br><span class="line">    &#125;</span><br><span class="line">    doIt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.logFoo();  <span class="comment">//logs "attempting to log this.foo: undefined"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/21/" target="_blank" rel="external">示例</a></p>
<p>上面示例中，<code>doIt</code> 函数中的<code>this</code>指代是全局作用域或者是<code>undefined</code>如果使用了<code>&quot;use strict&quot;;</code>声明的话。对于很多新手来说，理解这点是非常头疼的。</p>
<p>还有更奇葩的。把实例的方法作为参数传递时，实例是不会跟着过去的。也就是说，此时方法中的<code>this</code>在调用时指向的是全局<code>this</code>或者是<code>undefined</code>在声明了<code>&quot;use strict&quot;;</code>时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></span><br><span class="line">doIt(thing.logFoo); <span class="comment">//logs undefined</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/22/" target="_blank" rel="external">示例</a></p>
<p>所以很多人习惯将<code>this</code>缓存起来，用个叫<code>self</code>或者其他什么的变量来保存，以将外层与内层的<code>this</code>区分开来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> info = <span class="string">"attempting to log this.foo:"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(info, self.foo);</span><br><span class="line">    &#125;</span><br><span class="line">    doIt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.logFoo();  <span class="comment">//logs "attempting to log this.foo: bar"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/23/" target="_blank" rel="external">示例</a></p>
<p>…但上面的方式不是万能的，在将方法做为参数传递时，就不起作用了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(self.foo);</span><br><span class="line">    &#125;</span><br><span class="line">    doIt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doItIndirectly</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></span><br><span class="line">doItIndirectly(thing.logFoo); <span class="comment">//logs undefined</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/24/" target="_blank" rel="external">示例</a></p>
<p>解决方法就是传递的时候使用<code>bind</code>方法显示指明上下文，<code>bind</code>方法是所有函数或方法都具有的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">doIt(thing.logFoo.bind(thing)); <span class="comment">//logs bar</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/25/" target="_blank" rel="external">示例</a></p>
<p>同时也可以使用<code>apply</code>或<code>call</code> 来调用该方法或函数，让它在一个新的上下文中执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">    &#125;</span><br><span class="line">    doIt.apply(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doItIndirectly</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">doItIndirectly(thing.logFoo.bind(thing)); <span class="comment">//logs bar</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/26/" target="_blank" rel="external">示例</a></p>
<p>使用<code>bind</code>可以任意改变函数或方法的执行上下文，即使它没有被绑定到一个实例的原型上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logFoo</span>(<span class="params">aStr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(aStr, <span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">logFoo.bind(thing)(<span class="string">"using bind"</span>); <span class="comment">//logs "using bind bar"</span></span><br><span class="line">logFoo.apply(thing, [<span class="string">"using apply"</span>]); <span class="comment">//logs "using apply bar"</span></span><br><span class="line">logFoo.call(thing, <span class="string">"using call"</span>); <span class="comment">//logs "using call bar"</span></span><br><span class="line">logFoo(<span class="string">"using nothing"</span>); <span class="comment">//logs "using nothing undefined"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/27/" target="_blank" rel="external">示例</a></p>
<p>避免在构造函数中返回作何东西，因为返回的东西可能覆盖本来该返回的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.logFoo(); <span class="comment">//Uncaught TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/28/" target="_blank" rel="external">示例</a></p>
<p>但，如果你在构造函数里返回的是个原始值比如字符串或者数字什么的，上面的错误就不会发生了，返回语句将被忽略。所以最好别在一个将要通过<code>new</code>来调用的构造函数中返回作何东西，即使你是清醒的。如果你想实现工厂模式，那么请用一个函数来创建实例，并且不通过<code>new</code>来调用。当然这只是个人建议。</p>
<p>诚然，你也可以使用<code>Object.create</code>从而避免使用<code>new</code>。这样也能创建一个实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing =  <span class="built_in">Object</span>.create(Thing.prototype);</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/29/" target="_blank" rel="external">示例</a></p>
<p>这种方式不会调用该构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing =  <span class="built_in">Object</span>.create(Thing.prototype);</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/30/" target="_blank" rel="external">示例</a></p>
<p>正因为<code>Object.create</code>没有调用构造函数，这在当你想实现一个继承时是非常有用的，随后你可能想要重写构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Thing1.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.logFoo(); <span class="comment">//logs "bar"</span></span><br><span class="line">    Thing1.apply(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.logFoo(); <span class="comment">//logs "foo"</span></span><br><span class="line">&#125;</span><br><span class="line">Thing2.prototype = <span class="built_in">Object</span>.create(Thing1.prototype);</span><br><span class="line">Thing2.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing2();</span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/32/" target="_blank" rel="external">示例</a></p>
<h1 id="对象中的this">对象中的<code>this</code></h1><p>可以在对象的任何方法中使用<code>this</code>来访问该对象的属性。这与用<code>new</code>得到的实例是不一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">    logFoo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.logFoo(); <span class="comment">//logs "bar"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/33/" target="_blank" rel="external">示例</a></p>
<p>注意这里并没有使用<code>new</code>，也没有用<code>Object.create</code>，更没有函数的调用来创建对象。也可以将函数绑定到对象，就好像这个对象是一个实例一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    foo: <span class="string">"bar"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logFoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logFoo.apply(obj); <span class="comment">//logs "bar"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/34/" target="_blank" rel="external">示例</a></p>
<p>此时使用<code>this</code>没有向上查找原型链的复杂工序。通过<code>this</code>所拿到的只是该对象身上的属性而以。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">    deeper: &#123;</span><br><span class="line">        logFoo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.deeper.logFoo(); <span class="comment">//logs undefined</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/35/" target="_blank" rel="external">示例</a></p>
<p>也可以不通过<code>this</code>，直接访问对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">    deeper: &#123;</span><br><span class="line">        logFoo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(obj.foo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.deeper.logFoo(); <span class="comment">//logs "bar"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/36/" target="_blank" rel="external">示例</a></p>
<h1 id="DOM_事件回调中的this">DOM 事件回调中的<code>this</code></h1><p>在DOM事件的处理函数中，<code>this</code>指代的是被绑定该事件的DOM元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Listener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).addEventListener(<span class="string">"click"</span>,</span><br><span class="line">       <span class="keyword">this</span>.handleClick);</span><br><span class="line">&#125;</span><br><span class="line">Listener.prototype.handleClick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//logs "&lt;div id="foo"&gt;&lt;/div&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = <span class="keyword">new</span> Listener();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).click();</span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/37/" target="_blank" rel="external">示例</a></p>
<p>…除非你通过<code>bind</code>人为改变了事件处理器的执行上下文。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Listener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).addEventListener(<span class="string">"click"</span>, </span><br><span class="line">        <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">Listener.prototype.handleClick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//logs Listener &#123;handleClick: function&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = <span class="keyword">new</span> Listener();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).click();</span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/38/" target="_blank" rel="external">示例</a></p>
<h1 id="HTML中的this">HTML中的<code>this</code></h1><p>HTML标签的属性中是可能写JS的，这种情况下<code>this</code>指代该HTML元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"foo"</span> <span class="attribute">onclick</span>=<span class="value">"console.log(this);"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="erlang"></span><br><span class="line">document.get<span class="variable">ElementById</span>(<span class="string">"foo"</span>).click(); //logs &lt;<span class="keyword">div</span> id=<span class="string">"foo"</span>...</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/40/" target="_blank" rel="external">示例</a></p>
<h1 id="重写this">重写<code>this</code></h1><p>无法重写<code>this</code>，因为它是一个关键字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">this</span> = &#123;&#125;;  <span class="comment">// Uncaught SyntaxError: Unexpected token this </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/41/" target="_blank" rel="external">示例</a></p>
<h1 id="eval中的this"><code>eval</code>中的<code>this</code></h1><p><code>eval</code> 中也可以正确获取当前的 <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">"console.log(this.foo)"</span>); <span class="comment">//logs "bar"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.logFoo();</span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/43/" target="_blank" rel="external">示例</a></p>
<p>这里存在安全隐患。最好的办法就是避免使用<code>eval</code>。</p>
<p>使用<code>Function</code>关键字创建的函数也可以获取<code>this</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(this.foo);"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/44/" target="_blank" rel="external">示例</a></p>
<h1 id="使用with时的this">使用<code>with</code>时的<code>this</code></h1><p>使用<code>with</code>可以将<code>this</code>人为添加到当前执行环境中而不需要显示地引用<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">        foo = <span class="string">"foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.logFoo(); <span class="comment">// logs "bar"</span></span><br><span class="line"><span class="built_in">console</span>.log(thing.foo); <span class="comment">// logs "foo"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/45/" target="_blank" rel="external">示例</a></p>
<p>正如很多人认为的那样，使用<code>with</code>是不好的，因为会产生歧义。</p>
<h1 id="jQuery中的this">jQuery中的<code>this</code></h1><p>一如HTML DOM元素的事件回调，jQuery库中大多地方的<code>this</code>也是指代的DOM元素。页面上的事件回调和一些便利的静态方法比如<code>$.each</code> 都是这样的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"foo bar1"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"foo bar2"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">$(<span class="string">".foo"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//logs &lt;div class="foo...</span></span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">".foo"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//logs &lt;div class="foo...</span></span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">".foo"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.click();</span><br><span class="line">&#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/47/" target="_blank" rel="external">示例</a></p>
<h1 id="传递_this">传递 <code>this</code></h1><p>如果你用过<a href="http://underscorejs.org/" target="_blank" rel="external">underscore.js</a>或者<a href="http://lodash.com/" target="_blank" rel="external">lo-dash</a>你便知道，这两个库中很多方法你可以传递一个参数来显示指定执行的上下文。比如<code>_.each</code>。自ECMAScript 5 标准后，一些原生的JS方法也允许传递上下文，比如<code>forEach</code>。事实上，上文提到的<code>bind</code>，<code>apply</code>还有<code>call</code> 已经给我们手动指定函数执行上下文的能力了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.log = <span class="function"><span class="keyword">function</span> (<span class="params">thing</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.type, thing);</span><br><span class="line">&#125;</span><br><span class="line">Thing.prototype.logThings = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">   arr.forEach(<span class="keyword">this</span>.log, <span class="keyword">this</span>); <span class="comment">// logs "fruit apples..."</span></span><br><span class="line">   _.each(arr, <span class="keyword">this</span>.log, <span class="keyword">this</span>); <span class="comment">//logs "fruit apples..."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing(<span class="string">"fruit"</span>);</span><br><span class="line">thing.logThings([<span class="string">"apples"</span>, <span class="string">"oranges"</span>, <span class="string">"strawberries"</span>, <span class="string">"bananas"</span>]);</span><br></pre></td></tr></table></figure>
<p><a href="http://jsfiddle.net/btipling/25xkmho7/50/" target="_blank" rel="external">示例</a></p>
<p>这样可以使得代码简洁些，不用层层嵌套<code>bind</code>，也不用不断地缓存<code>this</code>。</p>
<p>一些编程语言上手很简单，比如<a href="http://golang.org/" target="_blank" rel="external">Go语言手册</a>可以被快速读完。然后你差不多就掌握这门语言了，只是在实战时会有些小的问题或陷阱在等着你。</p>
<p>而JavaScript不是这样的。手册难读。非常多缺陷在里面，以至于人们抽离出了<code>它好的部分</code>（<a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" target="_blank" rel="external">The Good Parts</a>）。最好的文档可能是<a href="https://developer.mozilla.org/en-US/" target="_blank" rel="external">MDN</a>上的了。所以我建议你看看他上面关于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external"><code>this</code></a>的介绍，并且始终在搜索JS相关问题时加上”mdn” 来获得最好的文档资料。静态代码检查也是个不错的工具，比如<a href="http://www.jshint.com/" target="_blank" rel="external">jshint</a>。</p>
<p>欢迎勘误及讨论，我的推特@bjorntipling。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>this</code> 虐我千百遍，看完此文效立见！不得不说，这篇文章的总结很地道很全面，适合收藏之用。</p>
<blockquote>
<p>原文：<a href="http://bjorn.tipling.com/all-this">all this</a></p>
</blockquote>
<p>习惯了高级语言的你或许觉得JavaScript中的<code>this</code>跟Java这些面向对象语言相似，保存了实体属性的一些值。其实不然。将它视作<a href="http://harrypotter.wikia.com/wiki/Boggart">幻影魔神</a>比较恰当，手提一个装满未知符文的<a href="http://harrypotter.wikia.com/wiki/Undetectable_Extension_Charm">灵龛</a>。</p>
<p>以下内容我希望广大同行们能够了解。全是掏箱底的干货，其中大部分占用了我很多时间才掌握。</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://wayou.github.io/tags/javascript/"/>
    
      <category term="译文" scheme="http://wayou.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于请求被挂起页面加载缓慢问题的追查（01/13更）]]></title>
    <link href="http://wayou.github.io/2014/12/31/chrome-request-stalled-problem/"/>
    <id>http://wayou.github.io/2014/12/31/chrome-request-stalled-problem/</id>
    <published>2014-12-31T20:38:22.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<p>本文前戏较多，务实的同学可以直接跳到结论。</p>
<a id="more"></a>
<p>由「<a href="http://movie.douban.com/subject/4876722/" target="_blank" rel="external">钢的琴</a>」网友脑洞大开延伸出了吉的他二的胡琵的琶，以及后来许嵩的「<a href="http://music.douban.com/subject/6033105/" target="_blank" rel="external">苏格拉没有底</a>」，是否可以再拓展一下，得到哥本不爱吃哈根，哈根爱达斯等剧情乱入的关系。</p>
<p>上面跟本文要讨论的主题有什么关系？</p>
<p>没关系。</p>
<h1 id="缘起">缘起</h1><p>有用户反馈内部MIS系统慢，页面加载耗时长。前端同学们开组会提及此事，如何解决慢的问题。</p>
<p>最致命的是：偶发！你不能准确知道它抽风的时间点，无法在想要追查问题的时候必现它。<br>这只是一方面，另外，慢的可能实在太多了，那么问题来了，是前端导致的还是后端的问题？</p>
<p>对慢的定义也有待商榷，多久算慢？如果这个页面加载大量数据耗时增加那我认为这是正常的。但这个时限超过了一个合理的自然值，就变得不那么正常了，比如四五十秒，一分多钟。</p>
<p>最奇葩的是，如此久的耗时居然不会报超时错误，而是拿到正确返回后将页面呈现了出来！</p>
<h1 id="可能的原因">可能的原因</h1><h2 id="初步猜测">初步猜测</h2><p>初步的猜测可能是后端迟迟未返回造成浏览器处于等待状态。这个猜测是很合乎逻辑的，至少能够很合理地解释Chrome Dev Tool 网络面板中我们看到的状态<code>pending</code>。<br><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/pending.jpg" alt=""></p>
<p>但我们不能停留在猜测阶段，要用事实说话，数据才不会骗人。这也正是本文将要展开的。</p>
<p>下面是另外一些被提出来的可能性。</p>
<h2 id="Angular">Angular</h2><p>Angular首当其冲。为什么，因为这个问题出现在后台MIS系统中，且这些系统多用Angular开发。</p>
<p>Angular ：怪我咯。</p>
<p>因为问题多出现在基于Angular的MIS系统中，并且Angular的性能一直是被诟病的，所以听到不少的声音将矛头指向Angular。这似乎没什么好庇护的。Angular在整个项目中的前端部分扮演了很重的角色。树大招风，理所当然。</p>
<p>这让我想起初次接触到这个问题时，那是在七月份，芙蓉的爱马仕平台用户反馈了慢的问题，报到前端，顺便看了下，一看<code>Pending</code>状态，觉得是后端未返回。只是情深缘浅当时也没有深入，同时洪堂大神负责去追查了。当时那个系统，很负责地说，没有用Angular。</p>
<p>所以这里可以为Angular正身，将其排除。</p>
<h2 id="内部封装的commonResource库">内部封装的<code>commonResource</code>库</h2><p>内部对Angular原生的<code>resource</code>进行了封装，做了些数据的转换处理。既然上面Angular都被正身了，那么这里的怀疑也是站不住脚的。</p>
<h2 id="Chrome插件">Chrome插件</h2><p>经查，网上好多呼声有说是Adblock等与网络有关的Chrome插件。可我不使用它已经很多年，那玩意儿太重，后来找到了算法更高级体量更轻便的<a href="https://chrome.google.com/webstore/detail/%C2%B5block/cjpalhdlnbpafiamejdnhcphjbkeiagm?hl=en" target="_blank" rel="external">µBlock</a>。关键是后者也在我使用一段时间后放弃了，因为个人觉悟提高了，免费内容是需要广告支撑的，如果你不希望付费变成强制的话。所以现在一直是处于未开这类插件的状态。那么在未开广告屏蔽插件的情况下重现了问题，可以排除这类插件的影响了。</p>
<p>关于插件，此刻我的Chrome里唯一还会接管Chrome网络的便是代理插件<a href="https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm?hl=en" target="_blank" rel="external">SwitchSharp</a>, 升级之后这货叫<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">Switchy哦卖喝</a>（与时俱进的我当然使用的是后者）。</p>
<h2 id="Chrome独家？">Chrome独家？</h2><p>因为内部MIS只兼容了Chrome开发，所以不会有在除了Chrome之外的浏览器上使用的场景，并且其他浏览器上面追查问题也是很痛苦的事情。这里仅在火狐里进行了少量尝试，未复现。同时接到反馈，Safari里也未复现。但也不能肯定就只有Chrome存在问题。似乎这个对于问题的解决还不那么重要，所以先不管。</p>
<h2 id="杀毒软件">杀毒软件</h2><p>后面会看到，在追查错误号<code>ERR_CONNECTION_RESET</code>时引出了杀毒软件可能会导致Chrome工作不正常的情况，但这个可能也在稍后被排除人。</p>
<p>并且，我厂使用Mac的同学并没有安装杀软，依然是可以复现的。</p>
<h1 id="重现">重现</h1><p>第一件事情便是重现。虽然是偶发，为了尽可能保存现场，还是想要手动将它刷出来。天不灭我，经过良久尝试，该问题被复现。于是各种截图，保存请求数据。这个时候还没有开启<code>chrome://net-internals/#events</code>页面来捕获事件日志。</p>
<p>为以后引用方便，这里留下版本信息：</p>
<blockquote>
<p>OS： Windows 7 Ultimate<br>Chrome：Version 39.0.2171.95 m</p>
</blockquote>
<p>这是请求<code>Pending</code>时的请求信息：<br><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/before-response.jpg" alt=""></p>
<p>这是请求成功返回后：<br><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/stalled-timeline.jpg" alt=""></p>
<p>可以看到<code>Stalled</code>了1分多钟。神奇的是竟然不报超时错误而是成功返回了。</p>
<p>同时保存了请求头，响应头，还将本次问题请求保存成了CURL等。现场已经留下，感觉Bug不会存活太久了。</p>
<p>接下来就是对比正常请求跟这次异常请求的不同，一轮比较下来，未发现多少异常。</p>
<h2 id="常态与变态的对比">常态与变态的对比</h2><p>请求头对比：</p>
<p>请求头的对比已丢失，但除了时间外，其余无差别。</p>
<p>响应头对比：</p>
<p><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/response-header-compaire.jpg" alt=""></p>
<p>返回结果对比：</p>
<p><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/response.jpg" alt=""></p>
<p>上面的对比意义不大，但还是要做的，万一发现有价值的情报了呢。</p>
<h1 id="一次失败的尝试">一次失败的尝试</h1><p>解决问题时，习惯性地看有没有人已经碰过到类似问题，这样做的好处很明显：<br>如果有，站在巨人的肩上轻松地牛逼着；<br>如果没有，这是个机会。</p>
<p>于是信心满满地出发了，因为根据一条互联网准则，70%的问题已经有人解决过了，那些没有被解决的要么是现有技术达不到，要么是未被人发现。所以能够搜索出问题答案的概率还是蛮大的。</p>
<p>经过旷日持久的搜索，有价值的参考寥寥无几。可能是问题本身太过奇葩，遇到的人太少；也有可能问题过于晦涩，无法表述；抑或我搜索的关键词不够精准。<br>倒也不是说一个都没找到，但一般涉及网络日志的情况就无人问津了，无人问津了！</p>
<p>比如<a href="http://stackoverflow.com/questions/14821725/ajax-request-over-https-hangs-for-40-seconds-in-chrome-only" target="_blank" rel="external">这个</a>，一年多前被人问的，现在还没有一个回答。</p>
<p>还比如这个</p>
<blockquote>
<p><a href="http://stackoverflow.com/questions/27513994/chrome-stalls-when-making-multiple-requests-to-same-resource" target="_blank" rel="external">Chrome stalls when making multiple requests to same resource?</a></p>
</blockquote>
<p>是后来作为参考的，也是无人问津了……</p>
<p>甚至自己也去问了<a href="http://stackoverflow.com/questions/27740692/request-stalled-for-a-long-time-occasionally-in-chrome" target="_blank" rel="external">一个</a>，依然无人问津了……</p>
<h2 id="神秘的CACHE_LOCK">神秘的CACHE LOCK</h2><p>上面提到，Stackoverflow上找到<a href="http://stackoverflow.com/questions/14821725/ajax-request-over-https-hangs-for-40-seconds-in-chrome-only" target="_blank" rel="external">一个问题</a>，跟现在需要解决一有些类似点：</p>
<ul>
<li>偶发，并不是必然出现的。这里我们的问题也是偶发，很难复现，需要反复刷。</li>
<li>也是请求被<code>Pending</code>了很久，从请求的时间线来看，体现在<code>Stalled</code>上。</li>
</ul>
<p>这一刻，有一种感觉大概是这样的：</p>
<blockquote>
<p>伟大的意大利的左后卫！他继承了意大利的光荣的传统。法切蒂、卡布里尼、马尔蒂尼在这一刻灵魂附体！格罗索一个人他代表了意大利足球悠久的历史和传统，在这一刻他不是一个人在战斗，他不是一个人！</p>
</blockquote>
<p>突然看到了希望。该提问到没有给出什么建设性的意见，但它后面的追加编辑却给出了答案。过程是查看Chrome的网络日志，在事件里面发现有一个超时错误：</p>
<blockquote>
<p>t=33627 [st=    5]      HTTP_CACHE_ADD_TO_ENTRY  [dt=20001]<br>                —&gt; net_error = -409 (ERR_CACHE_LOCK_TIMEOUT)</p>
</blockquote>
<p>耗时20秒之久！而且写得非常明显是<code>ERR_CACHE_LOCK_TIMEOUT</code>。根据提问者贴出来的链接，了解到Chrome有一个缓存锁的机制。</p>
<p>具体源于一个今年6月分实现的一个<a href="https://codereview.chromium.org/345643003" target="_blank" rel="external">补丁</a>，加入了这么个机制，而这个机制的引入又源于2010年的一个issue。具体信息可以通过这个<a href="https://code.google.com/p/chromium/issues/detail?id=46104" target="_blank" rel="external">这里</a>查看，下面引用如下。</p>
<blockquote>
<p>Basically here is the situation:</p>
<p>The site author has a long-lived XHR being used to stream a slow response from the server. This XHR response is cachable (it is just really slow). They kick off the XHR asynchronously, and as data slowly arrives on it, update the progressive load of the webpage. Cool.</p>
<p>Now what happens if you try to load this page in multiple tabs of Chrome is:<br>The first page starts to load just fine, but the second one does nothing.<br>What has happened, is the background XHR of the first page load has acquired an exclusive lock to the cache entry, and the background XHR of the second page is stalled at “Waiting for cache…” trying to get a reader access to the cache entry.</p>
<p>Since the first request can takes minutes, this is a problem.</p>
</blockquote>
<p><a href="mailto:eroman@chromium.org" target="_blank" rel="external">eroman</a> 同学指出了这么一个事实：</p>
<p>浏览器对一个资源发起请求前，会先检查本地缓存，此时这个请求对该资源对应的缓存的读写是独占的。那么问题来了，试想一下，当我新开一个标签尝试访问同一个资源的时候，这次请求也会去读取这个缓存，假设之前那次请求很慢，耗时很久，那么后来这次请求因为无法获取对该缓存的操作权限就一直处于等待状态。这样很不科学。于是有人建议优化一下。也就是上面所描述的那样。</p>
<p>随着问题的提出，还出了两种可能的实现方案。</p>
<blockquote>
<p>(a) [Flexible but complicated] Allow cache readers WHILE writing is in progress. This way the first request could still have exclusive access to the cache entry, but the second request could be streamed the results as they get written to the cache entry. The end result is the second page load would mirror the progress of the first one.</p>
<p>(a) [Naive but simpler] Have a timeout on how long we will block readers waiting for a cache entry before giving up and bypassing the cache.</p>
</blockquote>
<p>我猜上面第二个<code>(a)</code>应该是<code>(b)</code>。简单说第一种优化方案更加复杂但科学。之前的请求对缓存仍然是独占的，但随着前一次请求不断对缓存进行更新，可以把已经更新的部分拿给后面的请求读取，这样就不会完全阻塞后面的请求了。</p>
<p>第二种方案则更加简单暴力。给后来的请求设定一个读取缓存超时的时限，如果超过了这个时限，我认为缓存不可用或者本地没有缓存，忽略这一步直接发请求。</p>
<p>于是Chromium的开发者们选择了后者简单的实现。也就是<a href="https://codereview.chromium.org/345643003" target="_blank" rel="external">Issue 345643003: Http cache: Implement a timeout for the cache lock</a> 这个提交里的实现。</p>
<p>这个提交的描述如下：</p>
<blockquote>
<p>The cache has a single writer / multiple reader lock to avoid downloading the same resource n times. However, it is possible to block many tabs on the same resource, for instance behind an auth dialog.</p>
<p>This CL implements a 20 seconds timeout so that the scenario described in the bug results in multiple authentication dialogs (one per blocked tab) so the user can know what to do. It will also help with other cases when the single writer blocks for a long time.</p>
<p>The timeout is somewhat arbitrary but it should allow medium size resources to be downloaded before starting another request for the same item. The general solution of detecting progress and allow readers to start before the writer finishes should be implemented on another CL.</p>
</blockquote>
<p>于是就产生了上面题主遇到的情况。</p>
<p>所以他的解决方法就很明朗了，对请求加个时间戳让其变得唯一，或者服务器响应头设置为无缓存。Both will work!</p>
<p>那么我们的问题也会是这样的么？我幻想由于某种未知的原因造成之前的请求不正常（虽然网络面板里没有数据证明这样的阻塞请求在问题请求之前存在），然后我们的MIS里打开页面时读取不到缓存，卡了，一会儿缓存好了，正常了，于是在等待了几十秒后请求成功发出去了。</p>
<p>似乎不太可能。因为恰好内部MIS系统的响应头里已经加了缓存控制了 <code>Cache-Control: no-cache</code>。</p>
<p>以下是一次问题请求的响应头：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK&#10;Date: Wed, 31 Dec 2014 11:47:21 GMT&#10;Content-Type: application/json; charset=UTF-8&#10;Transfer-Encoding: chunked&#10;Connection: keep-alive&#10;Expires: Thu, 19 Nov 1981 08:52:00 GMT&#10;Pragma: no-cache&#10;Cache-Control: no-cache&#10;tracecode: 28410188240979065866123119&#10;tracecode: 28410188240506537994123119&#10;Server: Apache</span><br></pre></td></tr></table></figure>
<p>并且开多个标签也是无法进行有效重现的。</p>
<p>因此可以排除缓存的干扰。那么似乎这里的缓存锁并不是导致问题的原因，只能另寻他路。不得不说，高兴过后有点失望。</p>
<h2 id="八卦时间">八卦时间</h2><p>可喜的是，在细细口味了上面缓存机制引入的过程后，真是耐人寻味。这里不妨八卦一下。相信你也注意到了，上面提到，该<a href="https://code.google.com/p/chromium/issues/detail?id=46104" target="_blank" rel="external">缓存问题</a>的提出是在2010年，确切地说是<code>Jun 8, 2010</code>。是的，2010年6月8日由<a href="mailto:eroman@chromium.org" target="_blank" rel="external">eroman</a> 同学提出。但最后针对该问题进行修复的代码<a href="https://src.chromium.org/viewvc/chrome?revision=279326&amp;view=revision" target="_blank" rel="external">提交</a>却是在今年6月份，2014年6月24日，提交时间摆在那里我会乱说？</p>
<p><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/cache-fix-commit.jpg" alt=""></p>
<p>于是好奇为什么会拖了这么久，遂跟了一下该问题下面的回复看看发生了什么。简直惊呆了。</p>
<ul>
<li><p>同月14号，有了首次对这个问题的回复，那是将该问题指派给了<a href="mailto:rvargas@chromium.org" target="_blank" rel="external">rvargas</a>同学。</p>
</li>
<li><p>一个月过去了，也就是7月15号，<a href="mailto:rvargas@chromium.org" target="_blank" rel="external">rvargas</a>同学指出了与该问题关联的另外一个issue「<a href="https://code.google.com/p/chromium/issues/detail?id=6697" target="_blank" rel="external">issue 6697</a>」</p>
</li>
<li><p>接下来是8月5日，<a href="mailto:rvargas@chromium.org" target="_blank" rel="external">rvargas</a>同学为该问题贴上了标签<code>-Mstone-7 Mstone-8</code>，表明将会在里程碑7或者8里面进行修复。但在后面的10月7日，这个日程又被推到了<code>-Mstone-8 Mstone-9</code>。</p>
</li>
<li><p>再接下来11月5日，有人表示以目前的速度及bug数量，还没有时间来修复它，重点在处理优先级为<code>p1</code>的问题上。于是此问题又成功被顺延了，来到<code>-mstone-9 Mstone-10</code>，同时优级降为<code>p2</code>。Chromium人手也不够啊，看来。</p>
</li>
<li><p>时间来到12月9日，因为优先级为<code>p2</code>的issue如果没有被标为开始状态的话又自动推到下一个里程碑了，于是顺利来到 <code>-Mstone-10 MovedFrom-10 Mstone-11</code>。次年2月来到<code>-Mstone-11 Mstone-12</code>。完成了一次跨年！</p>
</li>
</ul>
<p>…………</p>
<ul>
<li><p>上面省略N步。如此反复，最后一次被推到了<code>-Mstone-16</code>，那是在2011年10月12日。</p>
</li>
<li><p>时间一晃来到2013年，这一年很平静，前面的几个月都没有人对此问题进行回复。直到11月27日，有人看不下去了，评论道：</p>
</li>
</ul>
<blockquote>
<p>This bug has been pushed to the next mstone forever…and is blocking more bugs (e.g <a href="https://code.google.com/p/chromium/issues/detail?id=31014)and" target="_blank" rel="external">https://code.google.com/p/chromium/issues/detail?id=31014)and</a> use-cases same video in 2 tags on one page, and adaptive bit rate html5 video streaming whenever that will kick in. Any chance this will be prioritized?</p>
</blockquote>
<p>由于这个bug的无限后延也阻塞了另外一些同类问题，看来是时候解决了。这不，最初的owner 当天就进行了回复：</p>
<blockquote>
<p>ecently there was someone looking at giving it another try… I’d have to see if there was any progress there.</p>
<p>If not, I may try to fix it in Q1.</p>
</blockquote>
<p>最后一句亮瞎。敢情这之前owner就没有想过要去真正解决似的，因为有其他人在看这个问题了，所以就没管了，如果Q1还没人解决的话，我会出手的！嗯，就是这个意思。</p>
<p>…………</p>
<p>最后，也就是上文提到的，2014年6月，还是<a href="mailto:rvargas@chromium.org" target="_blank" rel="external">rvargas</a>同学对这个问题进行了修复，实现了对缓存读取20秒超时的控制。</p>
<p>该问题就是这样从2010来到2014的。我怀疑Chrome是如何成为版本帝的。</p>
<h2 id="阶段总结">阶段总结</h2><p>仅有的希望到此似乎都没有了。不过前面的努力也不是没有作何收获，至少我得到了以下有价值的信息：</p>
<ul>
<li>谷歌的神坛光环不再那么耀眼，他们的产品也是有Bug的</li>
<li>Chrome 处理issue的效率，当然不排除这种大型项目bug数量跟人力完全不匹配的情况</li>
<li>受上面Stackoverflow问题的启发，接下来我将重点转移到了针对出问题请求的日志分析上，并且取得了突破</li>
</ul>
<h1 id="开始新的征程">开始新的征程</h1><p>虽然上面的努力没能定位到问题，但作为这次对解决这次问题的尝试，还是将它记录了下来，估且称作「旧的回忆」吧。</p>
<p>下面开始「新的征程」。</p>
<p><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/new-journey.jpg" alt=""></p>
<h1 id="再次重现">再次重现</h1><p>这次受到上面的启发，开启<code>chrome://net-internals/#events</code>页面来捕获事件日志。看是否有错误或异常发生。</p>
<p>再次经过旷日持久的机械操作，重现了！这次，日志在手，天下我有。感觉Bug不会存活多久了。</p>
<p>Chrome Dev Tools 网络面板截图：<br><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/timeline-screen-capture2.jpg" alt=""></p>
<p>由上面的截图看到，本次出问题的请求总耗时42.74秒。</p>
<p>问题请求的时间线信息截图：<br><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/timeline-screen-capture.jpg" alt=""></p>
<p>可以预见，通过捕获的日志完全可以看到<code>Stalled</code>那么久都发生了些什么鬼。</p>
<p>话不多说，切换到事件捕获页面，定位到出问题的请求，查看其详情。同时将该日志导出，永久保存！作为纪念，也方便以后再次导入查看。有兴趣的同学可以访问下方下载后进行导入，就可以清晰地查看到现场了，就好像你亲历了整个犯罪现场一样。</p>
<h2 id="日志还原">日志还原</h2><ul>
<li><p><a href="https://gist.githubusercontent.com/wayou/39772215d075c80d643a/raw/9c91463f22016d20c90de19e77ae3e4f302e0769/gistfile1.txt" target="_blank" rel="external">下载该日志文件</a></p>
</li>
<li><p>在Chrome新开一个标签输入<code>chrome://net-internals/#events</code></p>
</li>
<li>切换到<code>Import</code>，选择刚才下载的JSON文件进行导入</li>
<li>切换到<code>Events</code>，定位到<code>http://qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1.0.593</code> 这个请求</li>
</ul>
<p>此刻右边出现的便是该问题请求的详细日志。</p>
<h2 id="日志解读">日志解读</h2><p>下面不妨把日志文件贴出来先：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">193486: URL_REQUEST&#10;http://qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1.0.593&#10;Start Time: 2015-01-02 17:51:05.323&#10;&#10;t=    1 [st=    0] +REQUEST_ALIVE  [dt=42741]&#10;t=    1 [st=    0]    URL_REQUEST_DELEGATE  [dt=0]&#10;t=    1 [st=    0]   +URL_REQUEST_START_JOB  [dt=42740]&#10;                      --&#62; load_flags = 339804160 (BYPASS_DATA_REDUCTION_PROXY | MAYBE_USER_GESTURE | REPORT_RAW_HEADERS | VERIFY_EV_CERT)&#10;                      --&#62; method = &#34;GET&#34;&#10;                      --&#62; priority = &#34;LOW&#34;&#10;                      --&#62; url = &#34;http://qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1.0.593&#34;&#10;t=    2 [st=    1]      URL_REQUEST_DELEGATE  [dt=0]&#10;t=    2 [st=    1]      HTTP_CACHE_GET_BACKEND  [dt=0]&#10;t=    2 [st=    1]      HTTP_CACHE_OPEN_ENTRY  [dt=0]&#10;t=    2 [st=    1]      HTTP_CACHE_ADD_TO_ENTRY  [dt=0]&#10;t=    2 [st=    1]      HTTP_CACHE_READ_INFO  [dt=0]&#10;t=    2 [st=    1]      URL_REQUEST_DELEGATE  [dt=0]&#10;t=    2 [st=    1]     +HTTP_STREAM_REQUEST  [dt=2]&#10;t=    4 [st=    3]        HTTP_STREAM_REQUEST_BOUND_TO_JOB&#10;                          --&#62; source_dependency = 193488 (HTTP_STREAM_JOB)&#10;t=    4 [st=    3]     -HTTP_STREAM_REQUEST&#10;t=    4 [st=    3]     +HTTP_TRANSACTION_SEND_REQUEST  [dt=0]&#10;t=    4 [st=    3]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS&#10;                          --&#62; GET /release/getReleaseHistory?projectId=fum1.0.593 HTTP/1.1&#10;                              Host: qa.tieba.baidu.com&#10;                              Connection: keep-alive&#10;                              Accept: application/json, text/plain, */*&#10;                              User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&#10;                              Referer: http://qa.tieba.baidu.com/project/&#10;                              Accept-Encoding: gzip, deflate, sdch&#10;                              Accept-Language: en-US,en;q=0.8&#10;                              Cookie: [268 bytes were stripped]&#10;t=    4 [st=    3]     -HTTP_TRANSACTION_SEND_REQUEST&#10;t=    4 [st=    3]     +HTTP_TRANSACTION_READ_HEADERS  [dt=21301]&#10;t=    4 [st=    3]        HTTP_STREAM_PARSER_READ_HEADERS  [dt=21301]&#10;                          --&#62; net_error = -101 (ERR_CONNECTION_RESET)&#10;t=21305 [st=21304]        HTTP_TRANSACTION_RESTART_AFTER_ERROR&#10;                          --&#62; net_error = -101 (ERR_CONNECTION_RESET)&#10;t=21305 [st=21304]     -HTTP_TRANSACTION_READ_HEADERS&#10;t=21305 [st=21304]     +HTTP_STREAM_REQUEST  [dt=3]&#10;t=21307 [st=21306]        HTTP_STREAM_REQUEST_BOUND_TO_JOB&#10;                          --&#62; source_dependency = 193494 (HTTP_STREAM_JOB)&#10;t=21308 [st=21307]     -HTTP_STREAM_REQUEST&#10;t=21308 [st=21307]     +HTTP_TRANSACTION_SEND_REQUEST  [dt=3]&#10;t=21308 [st=21307]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS&#10;                          --&#62; GET /release/getReleaseHistory?projectId=fum1.0.593 HTTP/1.1&#10;                              Host: qa.tieba.baidu.com&#10;                              Connection: keep-alive&#10;                              Accept: application/json, text/plain, */*&#10;                              User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&#10;                              Referer: http://qa.tieba.baidu.com/project/&#10;                              Accept-Encoding: gzip, deflate, sdch&#10;                              Accept-Language: en-US,en;q=0.8&#10;                              Cookie: [268 bytes were stripped]&#10;t=21311 [st=21310]     -HTTP_TRANSACTION_SEND_REQUEST&#10;t=21311 [st=21310]     +HTTP_TRANSACTION_READ_HEADERS  [dt=21304]&#10;t=21311 [st=21310]        HTTP_STREAM_PARSER_READ_HEADERS  [dt=21304]&#10;                          --&#62; net_error = -101 (ERR_CONNECTION_RESET)&#10;t=42615 [st=42614]        HTTP_TRANSACTION_RESTART_AFTER_ERROR&#10;                          --&#62; net_error = -101 (ERR_CONNECTION_RESET)&#10;t=42615 [st=42614]     -HTTP_TRANSACTION_READ_HEADERS&#10;t=42615 [st=42614]     +HTTP_STREAM_REQUEST  [dt=12]&#10;t=42627 [st=42626]        HTTP_STREAM_REQUEST_BOUND_TO_JOB&#10;                          --&#62; source_dependency = 193498 (HTTP_STREAM_JOB)&#10;t=42627 [st=42626]     -HTTP_STREAM_REQUEST&#10;t=42627 [st=42626]     +HTTP_TRANSACTION_SEND_REQUEST  [dt=2]&#10;t=42627 [st=42626]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS&#10;                          --&#62; GET /release/getReleaseHistory?projectId=fum1.0.593 HTTP/1.1&#10;                              Host: qa.tieba.baidu.com&#10;                              Connection: keep-alive&#10;                              Accept: application/json, text/plain, */*&#10;                              User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&#10;                              Referer: http://qa.tieba.baidu.com/project/&#10;                              Accept-Encoding: gzip, deflate, sdch&#10;                              Accept-Language: en-US,en;q=0.8&#10;                              Cookie: [268 bytes were stripped]&#10;t=42629 [st=42628]     -HTTP_TRANSACTION_SEND_REQUEST&#10;t=42629 [st=42628]     +HTTP_TRANSACTION_READ_HEADERS  [dt=112]&#10;t=42629 [st=42628]        HTTP_STREAM_PARSER_READ_HEADERS  [dt=112]&#10;t=42741 [st=42740]        HTTP_TRANSACTION_READ_RESPONSE_HEADERS&#10;                          --&#62; HTTP/1.1 200 OK&#10;                              Date: Fri, 02 Jan 2015 09:51:48 GMT&#10;                              Content-Type: application/json; charset=UTF-8&#10;                              Transfer-Encoding: chunked&#10;                              Connection: keep-alive&#10;                              Cache-Control: no-cache&#10;                              tracecode: 31079600320335034634010217&#10;                              tracecode: 31079600320537995786010217&#10;                              Server: Apache&#10;t=42741 [st=42740]     -HTTP_TRANSACTION_READ_HEADERS&#10;t=42741 [st=42740]      HTTP_CACHE_WRITE_INFO  [dt=0]&#10;t=42741 [st=42740]      HTTP_CACHE_WRITE_DATA  [dt=0]&#10;t=42741 [st=42740]      HTTP_CACHE_WRITE_INFO  [dt=0]&#10;t=42741 [st=42740]      URL_REQUEST_DELEGATE  [dt=0]&#10;t=42741 [st=42740]   -URL_REQUEST_START_JOB&#10;t=42741 [st=42740]    URL_REQUEST_DELEGATE  [dt=0]&#10;t=42741 [st=42740]    HTTP_TRANSACTION_READ_BODY  [dt=0]&#10;t=42741 [st=42740]    HTTP_CACHE_WRITE_DATA  [dt=0]&#10;t=42741 [st=42740]    HTTP_TRANSACTION_READ_BODY  [dt=0]&#10;t=42741 [st=42740]    HTTP_CACHE_WRITE_DATA  [dt=0]&#10;t=42742 [st=42741] -REQUEST_ALIVE</span><br></pre></td></tr></table></figure>
<p>首先，日志显示的总耗时与上面网络面板截图的总耗时是吻合的，都是42.74秒，说明我们定位正确。</p>
<blockquote>
<p>以下时间均以毫秒计</p>
</blockquote>
<p>日志第一列为时间线，自请求发起时算。<br>第二列为每步操作所逝去的时间，时间差的概念，与第三列里面的<code>dt</code>不同，它会积累前面的耗时。<br>第三列为具体的事件，以及相应事件的耗时<code>dt</code>，此耗时为绝对耗时。</p>
<p><code>+</code>号对应事件开始，<code>-</code>号对应事件结束，也就是说他们必然成对出现。住里是展开后更加详细的子事件。直到不能再细分。</p>
<p>如果说一开始接触到这个日志时手足无措的话，我们来看一下正常情况下的日志是怎样的，有对比才有发现。</p>
<p>以下随便摘取一次正常请求的日志，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">384462: URL_REQUEST&#10;http://qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1.0.593&#10;Start Time: 2015-01-03 20:23:54.698&#10;&#10;t=1556 [st=  0] +REQUEST_ALIVE  [dt=172]&#10;t=1556 [st=  0]    URL_REQUEST_DELEGATE  [dt=0]&#10;t=1556 [st=  0]   +URL_REQUEST_START_JOB  [dt=171]&#10;                   --&#62; load_flags = 335609856 (BYPASS_DATA_REDUCTION_PROXY | MAYBE_USER_GESTURE | VERIFY_EV_CERT)&#10;                   --&#62; method = &#34;GET&#34;&#10;                   --&#62; priority = &#34;LOW&#34;&#10;                   --&#62; url = &#34;http://qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1.0.593&#34;&#10;t=1557 [st=  1]     +URL_REQUEST_DELEGATE  [dt=4]&#10;t=1557 [st=  1]        DELEGATE_INFO  [dt=4]&#10;                       --&#62; delegate_info = &#34;extension Tampermonkey&#34;&#10;t=1561 [st=  5]     -URL_REQUEST_DELEGATE&#10;t=1561 [st=  5]      HTTP_CACHE_GET_BACKEND  [dt=0]&#10;t=1561 [st=  5]      HTTP_CACHE_OPEN_ENTRY  [dt=1]&#10;                     --&#62; net_error = -2 (ERR_FAILED)&#10;t=1562 [st=  6]      HTTP_CACHE_CREATE_ENTRY  [dt=0]&#10;t=1562 [st=  6]      HTTP_CACHE_ADD_TO_ENTRY  [dt=0]&#10;t=1562 [st=  6]      URL_REQUEST_DELEGATE  [dt=0]&#10;t=1562 [st=  6]     +HTTP_STREAM_REQUEST  [dt=2]&#10;t=1564 [st=  8]        HTTP_STREAM_REQUEST_BOUND_TO_JOB&#10;                       --&#62; source_dependency = 384467 (HTTP_STREAM_JOB)&#10;t=1564 [st=  8]     -HTTP_STREAM_REQUEST&#10;t=1564 [st=  8]     +HTTP_TRANSACTION_SEND_REQUEST  [dt=1]&#10;t=1564 [st=  8]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS&#10;                       --&#62; GET /release/getReleaseHistory?projectId=fum1.0.593 HTTP/1.1&#10;                           Host: qa.tieba.baidu.com&#10;                           Connection: keep-alive&#10;                           Accept: application/json, text/plain, */*&#10;                           User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&#10;                           Referer: http://qa.tieba.baidu.com/project/&#10;                           Accept-Encoding: gzip, deflate, sdch&#10;                           Accept-Language: en-US,en;q=0.8&#10;                           Cookie: [2642 bytes were stripped]&#10;t=1565 [st=  9]     -HTTP_TRANSACTION_SEND_REQUEST&#10;t=1565 [st=  9]     +HTTP_TRANSACTION_READ_HEADERS  [dt=161]&#10;t=1565 [st=  9]        HTTP_STREAM_PARSER_READ_HEADERS  [dt=160]&#10;t=1725 [st=169]        HTTP_TRANSACTION_READ_RESPONSE_HEADERS&#10;                       --&#62; HTTP/1.1 200 OK&#10;                           Date: Sat, 03 Jan 2015 12:23:54 GMT&#10;                           Content-Type: application/json; charset=UTF-8&#10;                           Transfer-Encoding: chunked&#10;                           Connection: keep-alive&#10;                           Cache-Control: no-cache&#10;                           tracecode: 14346880480340800522010320&#10;                           tracecode: 14346880480253893130010320&#10;                           Server: Apache&#10;t=1726 [st=170]     -HTTP_TRANSACTION_READ_HEADERS&#10;t=1726 [st=170]      HTTP_CACHE_WRITE_INFO  [dt=0]&#10;t=1726 [st=170]      HTTP_CACHE_WRITE_DATA  [dt=0]&#10;t=1726 [st=170]      HTTP_CACHE_WRITE_INFO  [dt=0]&#10;t=1726 [st=170]     +URL_REQUEST_DELEGATE  [dt=1]&#10;t=1726 [st=170]        DELEGATE_INFO  [dt=1]&#10;                       --&#62; delegate_info = &#34;extension Tampermonkey&#34;&#10;t=1727 [st=171]     -URL_REQUEST_DELEGATE&#10;t=1727 [st=171]   -URL_REQUEST_START_JOB&#10;t=1727 [st=171]    URL_REQUEST_DELEGATE  [dt=0]&#10;t=1727 [st=171]    HTTP_TRANSACTION_READ_BODY  [dt=0]&#10;t=1727 [st=171]    HTTP_CACHE_WRITE_DATA  [dt=1]&#10;t=1728 [st=172]    HTTP_TRANSACTION_READ_BODY  [dt=0]&#10;t=1728 [st=172]    HTTP_CACHE_WRITE_DATA  [dt=0]&#10;t=1728 [st=172] -REQUEST_ALIVE</span><br></pre></td></tr></table></figure>
<p>针对上面正常的请求，我们主要关注两部分，如下面的截图：</p>
<ul>
<li>发送请求头 <code>+HTTP_TRANSACTION_SEND_REQUEST  [dt=1]</code></li>
<li>读取响应头 <code>+HTTP_TRANSACTION_READ_HEADERS  [dt=161]</code></li>
</ul>
<p><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/normal-section.jpg" alt=""></p>
<p>这是正常的情况下，没有什么问题。并且日志里可以清晰地看到发送的请求头是什么，然后解析出来的响应头是什么。这跟在网络面板看到的是一致的。</p>
<p>再回到出问题的请求日志上来，同样我们只关注这两部分。如下面的截图：</p>
<p><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/3retry.jpg" alt=""></p>
<p>与正常相比，最后一次发送请求和读取响应头无异常，时间就多在了前面还有再次发送和请求的过程，细看时间都花在了以下两个事件中：</p>
<ul>
<li><code>HTTP_STREAM_PARSER_READ_HEADERS  [dt=21301]</code></li>
<li><code>HTTP_STREAM_PARSER_READ_HEADERS  [dt=21304]</code></li>
</ul>
<p>该事件的名称已经自我解读，意思是解析读取的响应头。但问题是紧接着下面报错了，</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">--&#62; net_error = -101 (ERR_CONNECTION_RESET)</span><br></pre></td></tr></table></figure>
<p>读取响应头时发生了链接重置的错误，有理由认为本次链接是不成功的，没拿到正确的响应头，于是解析不成功。时间都花在了这里，足足21秒之久，两个21秒造就了上面看到的<code>Stalled</code>了42秒之久。</p>
<p>问题似乎已经很明朗了。链接被重置。</p>
<p>在第三次尝试的时候正常了，于是正确返回，我们才看到了被解析的响应头被展示在了下面。也就是说在出问题的时候要么响应头未拿到，要么响应头非法导致解析不成功。而原因就是链接被重置。</p>
<p>那么接下来的工作就是对<code>ERR_CONNECTION_RESET</code>这个错误的追查了。</p>
<h1 id="官方关于_ERR_CONNECTION_RESET_错误的解释">官方关于 <code>ERR_CONNECTION_RESET</code> 错误的解释</h1><p>未找到官方相应的资料，Chrome官网上唯一<a href="https://support.google.com/chrome/answer/117804?hl=en" target="_blank" rel="external">关于此错误的描述</a>是在安装Chrome时出现Error 101。我估计文档的撰写人员没想到谁会这么蛋疼想要看这些生涩的东西，除了开发者。既然你都是开发者了，那为什么不去看Chromium的源码。</p>
<p>好吧，唯一的途径似乎只能从源码中寻找了。作为只精JS的前端人员，现在要从C，C++代码中找答案了。估计追完这个问题，我会尝试为Chromium贡献代码。</p>
<p>慢着，在这之前，还是搜到一些关于这个错误的信息的。但似乎都不怎么靠谱。</p>
<p>比如<a href="http://blog.agmon.com/2013/07/05/solving-error-101-neterr_connection_reset-the-connection-was-reset/" target="_blank" rel="external">这里</a>提到，是因为ISP网络问题，实在无太可能。还有<a href="http://www.tomshardware.com/answers/id-1982982/err-connection-reset-error-chrome.html" target="_blank" rel="external">这是神马</a>居然一个硬件网站但提到了这个错误，并且怀疑是杀软导致Chrome出问题，但杀软已经在上文被我们排除了。</p>
<h1 id="Chromium_源码">Chromium 源码</h1><p>那么这个错误究竟是什么。能不能找到点靠谱的解释。当然能，让我们进入到Chromium的源码中去。</p>
<h2 id="ERR_CONNECTION_RESET被唤起的地方">ERR_CONNECTION_RESET被唤起的地方</h2><p>在Chromium的源码中搜索该常量名，确实出现很多<a href="https://code.google.com/p/chromium/codesearch#search/&amp;q=ERR_CONNECTION_RESET&amp;sq=package:chromium&amp;type=cs" target="_blank" rel="external">结果</a>。联系到我们查看日志发现问题的上下文，是在解析响应头报的。所以我们定位到<code>http_stream_parser.cc</code>文件，同时注意到有一个文件叫<code>net_errors_win.cc</code>，所以猜测他是定义所有错误常量用的，也顺便打开之。</p>
<p>经过观察<code>src/net/base/net_errors_win.cc</code> 其路径和代码得知其中多为系统级别的错误，似乎跟我们的问题不是很关联，忽略该文件。</p>
<p><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/source.jpg" alt=""></p>
<p><code>http_stream_parser.cc</code>文件中，<code>ERR_CONNECTION_RESET</code>仅出现一次。这给我们定位带来了极大的便利。</p>
<figure class="highlight cpp"><figcaption><span>[chromium]//src/net/base/net_errors_win.cc</span><a href="https://code.google.com/p/chromium/codesearch#chromium/src/net/http/http_stream_parser.cc&q=ERR_CONNECTION_RESET&sq=package:chromium&dr=C" target="_blank" rel="external">http_stream_parser.cc</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns true if |error_code| is an error for which we give the server a</span></span><br><span class="line"><span class="comment">// chance to send a body containing error information, if the error was received</span></span><br><span class="line"><span class="comment">// while trying to upload a request body.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ShouldTryReadingOnUploadError</span><span class="params">(<span class="keyword">int</span> error_code)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (error_code == ERR_CONNECTION_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个<code>ShouldTryReadingOnUploadError</code> 的方法，注释耐人寻味，这个时候，这样的情景，能否正确解读注释成为了比读懂代码更重要（这是我在看JS代码时永远无法体味到的感觉），下面尽可能对它进行理解：</p>
<blockquote>
<p>在尝试发送一个请求体的时候，让服务器尝试发送一个带错误的响应体，如果我们接收到了该错误则返回<code>true</code></p>
</blockquote>
<p>我承认被上面的复杂从句打败！</p>
<p>那么我们来看这个方法被调用的场景。</p>
<p>现在我们点击上面的<code>ShouldTryReadingOnUploadError</code>方法，代码下方出现调用了该方法的地方，一共有两处。</p>
<p><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/call.jpg" alt=""></p>
<p>分别点击进行查看。</p>
<figure class="highlight cpp"><figcaption><span>459行DoSendHeadersComplete方法里进行了调用</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> HttpStreamParser::DoSendHeadersComplete(<span class="keyword">int</span> result) &#123;</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// In the unlikely case that the headers and body were merged, all the</span></span><br><span class="line">    <span class="comment">// the headers were sent, but not all of the body way, and |result| is</span></span><br><span class="line">    <span class="comment">// an error that this should try reading after, stash the error for now and</span></span><br><span class="line">    <span class="comment">// act like the request was successfully sent.</span></span><br><span class="line">    <span class="keyword">if</span> (request_headers_-&gt;BytesConsumed() &gt;= request_headers_length_ &amp;&amp;</span><br><span class="line">        ShouldTryReadingOnUploadError(result)) &#123;</span><br><span class="line">      upload_error_ = result;</span><br><span class="line">      <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然不太可能，但也不排除头部和请求体合并的情况，当所有头部发送完毕，请求体不一定，此时<code>result</code>便是需要稍后处理的一种错误，这里暂且先返回<code>OK</code>。</p>
</blockquote>
<figure class="highlight cpp"><figcaption><span>516行另一个DoSendBodyComplete方法里进行了调用</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> HttpStreamParser::DoSendBodyComplete(<span class="keyword">int</span> result) &#123;</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// If |result| is an error that this should try reading after, stash the</span></span><br><span class="line">    <span class="comment">// error for now and act like the request was successfully sent.</span></span><br><span class="line">    <span class="keyword">if</span> (ShouldTryReadingOnUploadError(result)) &#123;</span><br><span class="line">      upload_error_ = result;</span><br><span class="line">      <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>跟上面类似，如果<code>result</code>出错，稍后处理，先返回正常</p>
</blockquote>
<p>这也与我们在日志中看到的情况相符，在前面再次错误后，这次请求并没有终止结束，而是尝试到了第三次并且以成功结束的。</p>
<p>但不管怎样，从这两个方法，一个<code>DoSendHeadersComplete</code>， 另一个<code>DoSendBodyComplete</code>，身上能体现出请求确实已经发出去。</p>
<h2 id="TCP_RST">TCP RST</h2><p>另外，在<a href="https://code.google.com/p/chromium/codesearch#chromium/src/net/base/net_error_list.h" target="_blank" rel="external"><code>net_error_list.h</code></a>这个文件的109行，可以准确找到我们在日志中得到的101号错误。它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A connection was reset (corresponding to a TCP RST).</span></span><br><span class="line">NET_ERROR(CONNECTION_RESET, -<span class="number">101</span>)</span><br></pre></td></tr></table></figure>
<p>从括号中的进一步解释可以知道，它代表TCP连接重置。</p>
<h1 id="TCP">TCP</h1><p>那么问题来了，什么是TCP连接重置？什么会引发TCP连接重置。从<a href="http://blogs.technet.com/b/networking/archive/2009/08/12/where-do-resets-come-from-no-the-stork-does-not-bring-them.aspx" target="_blank" rel="external">这篇文章</a>中有比较详细的解答。</p>
<p>想要完全解释，本文似乎是不可能的了。但根据上面的文章，这里可以简单转述一下。</p>
<h2 id="什么是TCP连接">什么是TCP连接</h2><p>它是一种协议。当网络上一个节点想与另一个节点通信时，双方需要选建立连接。而这个连接过程需要大家都懂的一种约定，TCP就是事先定好的一种约定，于是我们采用它吧，于是其中一个节点按照这个约定发起一建立连接的请求，另一节点收到后，根据该约定，便能读懂这个请求里各字段的意思：哦，丫这是想约我呢。</p>
<h2 id="三次握手">三次握手</h2><p>继续上面的例子。A想与B通信，并且使用TCP。</p>
<p>首先A发起一个报文，其中包含自己的地址，想要连接的目标地址，自己用来连接的端口及目标机器的端口,etc.</p>
<p>B收到邀约，并且愿意付约。此刻B需要回传一个报文，告诉A我愿意跟你连接。</p>
<p>A收到B的肯定应答，到此A与B经历了三次通信或者说是握手，双方都没有异议，连接建立。</p>
<p>而连接断开的过程也颇为类似。双方中的一方比如说A先发起一个断开连接的报文FIN，B收到并确认，然后回传一个可以断开的报文FIN给A。此刻A收到并确认。此刻双方都确认后，连接可以安全断开，但还会保持一个等待断开的状态，大概持续4分钟，用于之前连接通路上未传输完成的数据进行善后。</p>
<h2 id="什么是重置">什么是重置</h2><p>上面提到了4分钟的等待时间，而重置RESET便是立即断开连接的手段。</p>
<h2 id="发生重置的情况">发生重置的情况</h2><p>到此重置的作用已然明了。也就是说，重置甚至算不上一个错误，它是TCP连接中的一种正常情况。但什么时候会发生重置，如何引起的。</p>
<p>上文列出了三种情况。</p>
<h3 id="SMB_Reset">SMB Reset</h3><p>简单举例来说，服务器提供了两个端口445，139进行服务，客户端同时去请求与这两个端口连接，服务器返回了两个端口可以被连接，此刻客户端择优选择一个进行连接，而重置另一个。</p>
<h3 id="Ack,_Reset">Ack, Reset</h3><p>报文重置发生主要有以下情况：</p>
<ul>
<li>服务器没有监听被请求的端口，无法建立连接</li>
<li>服务器此刻无法比如没有充裕的资源用来连接连接</li>
</ul>
<h3 id="TCP_Reset_due_to_no_response">TCP Reset due to no response</h3><p>由于没有响应而被重置。当发起连接的一方连续发送6次请求未得到回应，此刻默认他们之间已经通过三次握手建立了连接并且通信有问题，发起的一方将连接重置。</p>
<h3 id="Application_Reset">Application Reset</h3><p>除了上面的情况，找不到TCP内部自己发送的重置，则归为了这一类。程序内将连接重置。此种情况包含了所有你想得到想不到将连接断开的情况。有可能是程序内部逻辑重置的，所以不能完全认为此时发生了错误。</p>
<p>值得注意的是，上面列出的情况<strong>服务器的不确定性导致连接重置</strong>的可能性要合理些。Chrome 主动发起URL请求不太可能自己又重置掉，并且没有理由重置掉后又去重连。</p>
<h1 id="进一步解读日志文件">进一步解读日志文件</h1><p>上面Chromium源码部分的求证多少带有猜测成分。不妥。</p>
<p>因为没找到关于Chrome net-internal 日志的官方文档什么的，自身去解读始终是有局限的。不如提个ISSUE让Chromium开发人员来搭一把手吧。遂向Chromium提交ISSUE，请<a href="https://code.google.com/p/chromium/issues/detail?id=447463" target="_blank" rel="external">戳此查看</a>，虽然我不认为现在遇到的这个问题跟Chrome有关并且属于Chrome的Bug，目的仅仅是看他们能否帮忙给出合理的日志解读来定位问题。</p>
<p>三天后（有点热泪盈眶），有同学<a href="https://code.google.com/p/chromium/issues/detail?id=447463#c1" target="_blank" rel="external">回复</a>，将日志所体现的问题诊断得似乎很有道理，可信。</p>
<blockquote>
<p>1)  We have a bunch of connections to qa.tieba.baidu.com, all were used successfully, and are now idle.<br>2)  They all silently die for some reason, without us ever being informed.  My guess is your personal router times out the connection, but this could also be your ISP, the destination server, or ever a real network outage (A short one) that prevents us from getting the connection closed message.<br>3)  There’s a new request to qa.tieba.baidu.com.  We try to reuse a socket.  After 21 seconds, we get the server’s RST message (“I don’t have a connection to you.”).  Since it was a stale socket, we’re aware this sometimes happens, so we just retry…And get the next idle socket in the list, which, after 21 seconds, gives us the same reset message.  We try again, for the same reason.  This time we don’t have another stale socket to try, so we use a fresh one.  The request succeeds.</p>
<p>The real problem here is something is taking 21 seconds to send us the RST messages, despite the fact that a roundtrip to the server you’re talking to only takes about 100 milliseconds.</p>
</blockquote>
<ul>
<li><p>「之前有过很多成功的连接」，确实，因为出现加载缓慢的情况是偶发的，这之前有过很多正常的不卡的请求存在过。这里没有异议。</p>
</li>
<li><p>「他们都以未知的原因被断掉了」，因为不是正常地断开连接，所以客户端也就是浏览器不知道当前与服务器的TCP连接已经断开，傻傻地保留着与服务器连接的socket，注意，此时已经发生信息的不对等了，这是问题的根源。至于什么原因，给出了可能的原因：路由器认为连接超时将其断掉，同时不排除ISP（互联网服务提供商）的原因，服务器暂时的停运抽风等。不管怎样，客户端浏览器没有收到连接断开的信息。</p>
</li>
<li><p>在上面的基础上，我们去发起一次新的请求。此时浏览器希望重用之前的连接以节省资源，用之前的一个socket去发起连接。21秒后收到服务器返回的重置信息（意思是服务器告诉浏览器：我和你之间没有连接），没关系，上面提到，我们有很多可以重用的连接，于是浏览器重新从可用的连接里面又选择了一个去进行连接，不幸的是，同样的情况再次发生，21秒后收到服务器的重置信息。这体现在日志上就是第二次重试失败。到第三次，因为前面浏览器认为可以重用的连接现在都被正确地标为断开了，没有新的可用，于是这次浏览器发起了全新的请求，成功了！</p>
</li>
</ul>
<p>总结出来，两个问题：</p>
<ul>
<li>为什么之前成功的连接不正常的断开了？服务器配置或者网络原因？</li>
<li>是什么让浏览器21秒后才收到重置信息？服务器作出反应过慢还是网络原因？</li>
</ul>
<h1 id="Chrome_Dev_Tool_中时间线各阶段代表的意义">Chrome Dev Tool 中时间线各阶段代表的意义</h1><p>另附注一下Chrome Dev Tool 中请求的时间线各阶段代表的意义。<br>以下内容扒自<a href="https://developer.chrome.com/devtools/docs/network#resource-network-timing" target="_blank" rel="external">Chrome 开发者文档页</a>，然后我将它本地化了一下下。</p>
<p><img src="/asset/posts/2014-12-31-chrome-request-stalled-problem/timing.png" alt=""></p>
<h2 id="Stalled/Blocking">Stalled/Blocking</h2><p>在请求能够被发出去前的等等时间。包含了用于处理代理的时间。另外，如果有已经建立好的连接，那么这个时间还包括等待已建立连接被复用的时间，这个遵循Chrome对同一源最大6个TCP连接的规则。</p>
<p>「拿我们的情况来说，上面出错所有的耗时也是算在了这部分里面。网络面板中显示的其余时间比如DNS查找，连接建立等都是属于最后那次成功请求的了」</p>
<h2 id="Proxy_Negotiation">Proxy Negotiation</h2><p>处理代理的时间。</p>
<h2 id="DNS_Lookup">DNS Lookup</h2><p>查找DNS的时间。页面上每个新的域都需要一次完整的寻路来完成DNS查找。</p>
<h2 id="Initial_Connection_/_Connecting">Initial Connection / Connecting</h2><p>用于建立链接的时间，包括TCP握手及多次尝试握手，还有处理SSL。</p>
<h2 id="SSL">SSL</h2><p>完成SSL握手的时间。</p>
<h2 id="Request_Sent_/_Sending">Request Sent / Sending</h2><p>Time spent issuing the network request. Typically a fraction of a millisecond.</p>
<p>发起请求的时间，通常小到可以忽略。</p>
<h2 id="Waiting_(TTFB)">Waiting (TTFB)</h2><p>等待响应的时间，具体来说是等待返回首个字节的时间。包含了与服务器之间一个来回响应的时间和等待首个字节被返回的时间。</p>
<h2 id="Content_Download_/_Downloading">Content Download / Downloading</h2><p>用于下载响应的时间</p>
<h1 id="结论">结论</h1><p>我相信很多同学是直接跳到这里来了的。事实上我给不出什么解决方案，但能排除前端代码引起问题的可能性。</p>
<p>具体来说，能够得到的结论有以下几点：</p>
<ul>
<li>请求成功构造，排除前端代码层面导致问题的原因，是不是浏览器Bug有待确定</li>
<li>可以肯定的是在与服务器建立连接时被Shut down了，参考上面关于连接重置的部分会更有意义一些</li>
</ul>
<blockquote>
<p>01/13日更新：参见上面进一步解读日志文件部分。</p>
</blockquote>
<h1 id="参考及引用">参考及引用</h1><p>#1 <a href="http://stackoverflow.com/questions/27513994/chrome-stalls-when-making-multiple-requests-to-same-resource" target="_blank" rel="external">Chrome stalls when making multiple requests to same resource?</a><br>#2 <a href="http://stackoverflow.com/questions/5585918/what-does-pending-mean-for-request-in-chrome-developer-window" target="_blank" rel="external">What does “pending” mean for request in Chrome Developer Window?</a><br>#3 <a href="https://developer.chrome.com/devtools/docs/network#resource-network-timing" target="_blank" rel="external">Evaluating network performance / Resource network timing</a><br>#4 <a href="https://www.google.com/search?q=Provisional+headers+are+shown&amp;gws_rd=ssl" target="_blank" rel="external">Provisional headers are shown</a><br>#5 <a href="http://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger" target="_blank" rel="external">“CAUTION: provisional headers are shown” in Chrome debugger</a><br>#6 <a href="http://segmentfault.com/q/1010000000364871" target="_blank" rel="external">Chrome 里的请求报错 “CAUTION: Provisional headers are shown” 是什么意思?</a><br>#7 <a href="https://codereview.chromium.org/345643003" target="_blank" rel="external">Issue 345643003: Http cache: Implement a timeout for the cache lock</a><br>#8 <a href="https://code.google.com/p/chromium/issues/detail?id=46104" target="_blank" rel="external">Issue 46104:   Pages can get blocked in “Waiting for Cache” for a very long time</a><br>#9 <a href="http://dev.chromium.org/for-testers/providing-network-details" target="_blank" rel="external">Providing Network Details for bug reports</a><br>#10 <a href="http://div.io/topic/609?page=1#2050" target="_blank" rel="external">从FE的角度上再看输入url后都发生了什么</a><br>#11 <a href="https://code.google.com/p/chromium/codesearch#chromium/src/net/http/http_stream_parser.cc&amp;q=ERR_CONNECTION_RESET&amp;sq=package:chromium&amp;dr=C&amp;l=77" target="_blank" rel="external">ERR_CONNECTION_RESET 的Chromium 源码</a><br>#12 <a href="http://www.chromium.org/developers/design-documents/network-stack#TOC-HttpStreamFactory" target="_blank" rel="external">Chromium Network Stack</a><br>#13 <a href="http://blogs.technet.com/b/networking/archive/2009/08/12/where-do-resets-come-from-no-the-stork-does-not-bring-them.aspx" target="_blank" rel="external">Where do resets come from? (No, the stork does not bring them.)</a><br>#14 <a href="https://code.google.com/p/chromium/issues/detail?id=447463#c1" target="_blank" rel="external">Issue 447463: Chrome-network: Long delay before RST message on stale sockets results in slow page loads)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文前戏较多，务实的同学可以直接跳到结论。</p>]]>
    
    </summary>
    
      <category term="Chrome" scheme="http://wayou.github.io/tags/Chrome/"/>
    
      <category term="网络请求" scheme="http://wayou.github.io/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nexus 5 刷机及ROOT]]></title>
    <link href="http://wayou.github.io/2014/12/21/nexus-root/"/>
    <id>http://wayou.github.io/2014/12/21/nexus-root/</id>
    <published>2014-12-21T11:17:10.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>刷机有风险，root需谨慎！<br>following steps below on your own risk</p>
</blockquote>
<a id="more"></a>
<p>Google死忠入手一台Nexus是必需的事情。Nexus6 刚出，特别赞，但被尺寸吓到了，机身跟6 plus差不离。觉得这样的尺寸无法接受，遂入手Nexus5。我不算太能折腾，所以不想去刷机什么的。但问题来了，Android 5 棒棒糖太吸引人，Material Design 简直美Cry。</p>
<p>对于Google死忠来说，这样的诱惑是难以抵挡的。于是咬咬牙，升！</p>
<p>Nexus5 自带Android 4.4.3其实可以接收OTA自动升级到最新版本的。鉴于国内特殊情况，要完成顺利的升级你得懂得科学上网，而且是让手机科学上网。</p>
<p><img src="/asset/posts/2014-12-21-nexus-root/1.png" alt=""></p>
<p>科学上网只是第一步，保证你手机可以下载到更新，值得提及的是升级过程似乎只能一步一步来，4.4.3 到4.4.4，然后4.4.4 到 5.0， 最后才是5.0.1。</p>
<p>如果手机之前ROOT过，OTA有可能不会那么自动，更新包下载完成重启时可能进入安装界面，于是不知道怎么操作，也没搜到相关资料，只能手动刷了。</p>
<p>当然，如果你没有VPN，不能科学上网，你的唯一选择就只有手动刷了。</p>
<p>但先让我们来ROOT，因为官方都说了，安装新系统镜像前有可能需要<code>unlock</code>，所以为了提高成功率还是先ROOT一下。</p>
<h1 id="ROOT">ROOT</h1><h2 id="ROOT视频教程">ROOT视频教程</h2><p>你可以看<a href="http://v.youku.com/v_show/id_XODUzNDIyOTc2.html" target="_blank" rel="external">此视频教程</a>（从Youtube 扒到优酷的），也可以跟随下面的步骤，多体位任君选择。</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XODUzNDIyOTc2" frameborder="0" allowfullscreen></iframe>

<h2 id="准备">准备</h2><p>开始之前，你需要准备一些工具。包括了系统驱动及一些<code>adb</code>命令行工具等，可以<a href="http://downloadandroidrom.com/file/Nexus5/root/Nexus5Root.zip" target="_blank" rel="external">点此下载</a>。</p>
<h3 id="开启手机开发者选项">开启手机开发者选项</h3><p>开启手机开发者调试选项。</p>
<blockquote>
<p>Settings-&gt;About Phone</p>
</blockquote>
<p>进入「关于手机」界面，下拉到底部，连续点击<code>Build number</code> 直到出现提示说还剩多少次点击便可开启开发者选项，再继续，最后会提示你开启成功。</p>
<p><img src="/asset/posts/2014-12-21-nexus-root/3.jpg" alt=""></p>
<blockquote>
<p>图片来自<a href="http://www.cnet.com/how-to/how-to-easily-root-an-android-device/" target="_blank" rel="external">How to easily root an Android device</a></p>
</blockquote>
<p>然后返回到上一级，会多出一个菜单 <code>Developer options</code>,点击进入。选中<code>USB debugging</code>。</p>
<p><img src="/asset/posts/2014-12-21-nexus-root/4.png" alt=""></p>
<h3 id="驱动安装">驱动安装</h3><p>首先需要在电脑上安装识别手机的驱动。这里以Window为例。将手机用数据线连接到电脑。前面已经开启了USB调试选项，连接后，手机出现提示是否允许调试，选中同意。</p>
<ul>
<li><p>下载上面提到的<a href="http://downloadandroidrom.com/file/Nexus5/root/Nexus5Root.zip" target="_blank" rel="external">root工具</a>后解压。</p>
</li>
<li><p>进入Windows的设备管理器（控制面板-&gt;设备管理器）, 此时我们的手机应该是未识别的设备，有黄色图标。</p>
</li>
</ul>
<p><img src="/asset/posts/2014-12-21-nexus-root/5.jpg" alt=""></p>
<blockquote>
<p>双击该设备打开属性面板，然后选择「更新驱动」，在弹出的窗口中选择从本地电脑中选择驱动。</p>
</blockquote>
<p><img src="/asset/posts/2014-12-21-nexus-root/6.jpg" alt=""></p>
<blockquote>
<p>在弹出的窗口中再次选择从电脑中浏览，之后在弹出的窗口中直接点击「下一步」。</p>
</blockquote>
<p><img src="/asset/posts/2014-12-21-nexus-root/7.jpg" alt=""></p>
<blockquote>
<p>下一步窗口中选择<code>Have Disk...</code> 打开<code>Install From Disk</code> 窗口。选择「浏览」定位到之前解压的位置，选中<code>Nexus5Root\usb_driver\android_winusb.inf</code> 进行安装。</p>
</blockquote>
<p><img src="/asset/posts/2014-12-21-nexus-root/8.jpg" alt=""></p>
<blockquote>
<p>接下来选择<code>Android ADB Interface</code> 再点击「下一步」开始安装。</p>
</blockquote>
<p><img src="/asset/posts/2014-12-21-nexus-root/9.jpg" alt=""></p>
<p>到此，驱动安装完成！</p>
<h3 id="资料备份">资料备份</h3><p>如果你是新手机，没啥重要数据，或者通讯录什么的都云端备份了，这一步就可以省了。如果你想保存手机上的APP信息什么的，那就过一下此步骤吧。</p>
<p>注意这个时候你的手机应该是开机状态且用数据线连接到电脑了。</p>
<ul>
<li>还是在之前解压的文件夹下，按住左键在空白处右击，在出来的菜单中选择「在此处打开命令行」</li>
</ul>
<p><img src="/asset/posts/2014-12-21-nexus-root/10.png" alt=""></p>
<ul>
<li>输入<code>adb devices</code> 查看设备连接状态。第一次可能会需要在手机上弹出的确认窗口中点击一下确认。正常情况下命令行里会返回已经识别到的机器。</li>
</ul>
<p><img src="/asset/posts/2014-12-21-nexus-root/11.jpg" alt=""></p>
<ul>
<li>输入<code>adb backup -apk -all -f backup.ab</code> 进行资料备份。此时到手机上点击确定开始进行备份。</li>
</ul>
<p>分分钟后备份工作完毕！</p>
<h2 id="ROOT_进行时">ROOT 进行时</h2><p>接下来开始ROOT。</p>
<p>此时你的手机也保持和电脑连接的。</p>
<ul>
<li><p>先是手机关机。之后按住音量向下键和电源键，一定是同时按住，大概2秒后进入启动界面。 </p>
</li>
<li><p>此时你需要重复上面驱动安装的步骤再次安装一下驱动，如果设备管理器里面手机图标还是带黄色感叹号的话</p>
</li>
<li><p>还是在刚才的命令行里面，输入<code>fastboot oem unlock</code>，这就是鉴证奇迹的时刻。此时到手机上用音量键选择<code>YES</code> 然后按电源键来确认。然后系统开始擦除数据，进行ROOT。大概秒秒钟后完成。成功后会显示系统状态为<code>unlocked</code></p>
</li>
<li><p>然后用音量键选择<code>Start</code>模式启动手机</p>
</li>
</ul>
<p>此时手机启动后就焕然一新了，需要重新设置时间等。</p>
<h2 id="安装ROOT授权管理软件">安装ROOT授权管理软件</h2><p>接下来需要安装一个ROOT授权管理软件，以方便我们管理软件。</p>
<ul>
<li><p>开机后手机还是连接到电脑的。将解压包里的<code>UPDATE-SuperSU-v1.65.zip</code> 文件复制到手机SD卡</p>
</li>
<li><p>然后关机。还是以上面那种方式，按住音量向下键和电源键，直到启动界面出现</p>
</li>
<li><p>还是原来的命令行窗口里面，输入<code>fastboot flash recovery openrecovery-twrp-2.6.3.1-hammerhead.img</code> 写入<code>recovery</code> 程序</p>
</li>
<li><p>成功后到手机上，用音量键切换到<code>Recovery mode</code>，按电源键确定进入。此时手机重启，进入<code>recovery</code> 界面</p>
</li>
<li><p>选择<code>Install</code>, 然后找到你复制到SD卡中的<code>UPDATE-SuperSU-v1.65.zip</code>，选择中它。现在出现提示叫你「滑动来确定安装」，滑动安装之</p>
</li>
<li><p>秒秒钟后安装成功，选择重启系统</p>
</li>
</ul>
<p>重启后多了个 Super SU 软件，这个就是用来管理ROOT授权的。</p>
<p>到此系统ROOT完毕！</p>
<h2 id="资料还原">资料还原</h2><p>现在需要做的就是还原之前备份的资料。</p>
<p>此时手机已经焕然一新了，于是我们需要重复之前的步骤来开启手机的开发者调试选项。步骤见上文。</p>
<p>然后手机同样连接到电脑。</p>
<ul>
<li><p>输入<code>adb devices</code> 查看设备连接状态</p>
</li>
<li><p>输入<code>adb restore backup.ab</code> 进行还原。此时到手机上操作，选择恢复</p>
</li>
</ul>
<p>如果顺利的话，到此你的手机就ROOT成功并且数据还原完毕啦！</p>
<h1 id="手动升级Android_Lollipop">手动升级Android Lollipop</h1><p>如果之前是Android 4.x，建议先升5再升5.0.1。升级系统不必ROOT，但至少官方有如下提示：</p>
<blockquote>
<ol>
<li>If necessary, unlock the device’s bootloader by running:<br><code>fastboot oem unlock</code> </li>
</ol>
</blockquote>
<p>所以如果你之前尝试过升级不成功的话可以试试上面步骤先ROOT一下。并且对于喜欢折腾的发烧友们来说，手机不ROOT就无法DIY，各种摄手摄脚啊。</p>
<p>下面开始刷5.0.1系统。</p>
<h2 id="下载谷歌原厂系统镜像">下载谷歌原厂系统镜像</h2><p>到<a href="https://developers.google.com/android/nexus/images" target="_blank" rel="external">谷歌官网</a>下载适配机型的img系统镜像文件。这里我们选择最新的<a href="https://dl.google.com/dl/android/aosp/hammerhead-lrx22c-factory-0f9eda1b.tgz" target="_blank" rel="external">Nexus5 Android 5.0.1</a></p>
<p><img src="/asset/posts/2014-12-21-nexus-root/2.jpg" alt=""></p>
<h2 id="解压写入">解压写入</h2><p>此时你的手机连接到电脑并且开始的开发者调试模式。</p>
<p>将下载的文件解压。我的建议是将解压出来的文件与上面的root工具放一起，这样方便执行<code>adb</code> 命令时好找文件。</p>
<p>还是上面那个命令行工具，执行<code>adb reboot bootloader</code> 重启手机进入启动界面。</p>
<p>然后再执行<code>flash-all</code> 开始写入系统文件。</p>
<p>这一过程可能持续一会儿，分把钟的样子。</p>
<p>成功后如果你想解释ROOT状态，可以执行<code>fastboot oem lock</code>。</p>
<p>重启手机，感受全新的Material Design 美艳界面吧！</p>
<h2 id="手动写入">手动写入</h2><p>如果你在执行上面的<code>flash-all</code> 脚本时出现错误了，此时需要手机写入。</p>
<p>方法是将下载下来的系统文件解压后，里面会有一个包含很多系统相关镜像的压缩包文件<code>image-hammerhead-lrx22o.zip</code>，将它解压。</p>
<p>解压后你会得到</p>
<ul>
<li>android-info.txt</li>
<li>boot.img</li>
<li>cache.img</li>
<li>recovery.img</li>
<li>system.img</li>
<li>userdata.img</li>
</ul>
<p>这些文件.然后将这些文件同样放到跟adb工具一起，方便之后执行命令时不用多写路径。</p>
<p>开始手动写入。</p>
<ul>
<li>执行<code>fastboot flash bootloader bootloader-hammerhead-hhz12d.img</code> 这里的<code>bootloader-hammerhead-hhz12d.img</code> 文件名以你自己的为准，不同系统可能有不同</li>
<li>执行<code>fastboot flash radio radio-hammerhead-m8974a-2.0.50.2.22.img</code></li>
<li>执行<code>fastboot reboot-bootloader</code> 重启</li>
<li><p>再依次执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastboot flash recovery recovery.img</span><br><span class="line">fastboot flash boot boot.img</span><br><span class="line">fastboot flash system system.img</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是Nexus9 完成上面的步骤后需要执行 <code>fastboot flash vendor vendor.img</code>, <strong>注意：此步骤仅Nexus9需要</strong></p>
</li>
<li><p>执行<code>fastboot flash cache cache.img</code></p>
</li>
<li>执行<code>fastboot flash userdata userdata.img</code> </li>
</ul>
<p>到此，手动写入完成！</p>
<p>开机即可体验！！</p>
<h1 id="refernce">refernce</h1><ul>
<li><a href="http://rootnexus5.com/nexus-5-root/how-to-root-nexus-5/" target="_blank" rel="external">How to Root Nexus 5! [4.4.3/4.4.4/5.0]</a></li>
<li><a href="https://developers.google.com/android/nexus/images" target="_blank" rel="external">Factory Images for Nexus Devices</a></li>
<li><a href="http://www.androidpolice.com/2014/11/12/running-into-the-dreaded-missing-system-img-error-flashing-android-5-0-factory-images-heres-how-to-get-around-it/" target="_blank" rel="external">Running Into The Dreaded “missing system.img” Error Flashing Android 5.0 Factory Images? Here’s How To Get Around It</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>刷机有风险，root需谨慎！<br>following steps below on your own risk</p>
</blockquote>]]>
    
    </summary>
    
      <category term="android" scheme="http://wayou.github.io/tags/android/"/>
    
      <category term="nexus" scheme="http://wayou.github.io/tags/nexus/"/>
    
      <category term="科技有意思" scheme="http://wayou.github.io/categories/%E7%A7%91%E6%8A%80%E6%9C%89%E6%84%8F%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS currentColor 变量的使用]]></title>
    <link href="http://wayou.github.io/2014/12/07/css-currentColor/"/>
    <id>http://wayou.github.io/2014/12/07/css-currentColor/</id>
    <published>2014-12-07T12:56:22.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<p>CSS中存在一个神秘的变量，少有人知自然也不怎么为人所用。它就是<code>crrentColor</code>变量（或者说是CSS关键字，但我觉得称为变量好理解些）。</p>
<a id="more"></a>
<h1 id="初识">初识</h1><p>它是何物？具有怎样的功效？它从哪里来？带着这些疑问我们继续。</p>
<p>下面是来自<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#currentColor_keyword" target="_blank" rel="external">MDN的解释</a>：</p>
<blockquote>
<p><code>currentColor</code>代表了当前元素被应用上的<code>color</code>颜色值。 使用它可以将当前这个颜色值应用到其他属性上，或者嵌套元素的其他属性上。</p>
</blockquote>
<p>你这可以这么理解，CSS里你可以在任何需要写颜色的地方使用<code>currentColor</code>这个变量，这个变量的值是当前元素的<code>color</code>值。如果当前元素没有在CSS里显示地指定一个<code>color</code>值，那它的颜色值就遵从CSS规则，从父级元素继承而来。</p>
<p>到此似乎解决了上面三个哲学式的提问，但依然有些模糊。程序员之间的交流，还是上码才好。</p>
<ul>
<li>场景1</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>约么？<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>此时，<code>&lt;p&gt;</code>标签<code>currentColor</code>的值为<code>red</code>。</p>
<p><br></p>
<ul>
<li>场景2</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>约么？<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="class">.container</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#00ff00</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在，我们没有给<code>&lt;p&gt;</code>标签指定颜色，它的<code>color</code>从父级容器也就是<code>class</code>为<code>container</code>的<code>div</code>继承而来，换句话说此时<code>p</code>标签的<code>color</code>为<code>#00ff00</code>，<code>currentColor</code>又是直接去取元素的<code>color</code>值，所以此时<code>p</code>标签的<code>currentColor</code>值也为<code>#00ff00</code>。</p>
<p><img src="/asset/posts/2014-12-07-css-currentColor/situation2.jpg" alt="situation2"></p>
<ul>
<li>场景3</li>
</ul>
<p>如果父级元素也没有写<code>color</code>呢？其实这里都还是CSS规则的范畴，跟本文的主角关系不太大。但本着不啰嗦会死的原则，就展开了讲。</p>
<p>如果父级元素也没有指定颜色，那它的父级元素就会从父级的父级去继承，直到文档的根结点<code>html</code>标签都还没显示指定一个颜色呢，就应用上浏览器默认的颜色呗~</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">title</span>&gt;</span>我来组成头部<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span>约么？<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">footer</span>&gt;</span>战神金钢，宇宙的保护神！<span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 无CSS</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p><img src="/asset/posts/2014-12-07-css-currentColor/situation3.jpg" alt="situation3"></p>
<p>那，这个时候的黑色其实是浏览器默认给的。此时<code>p</code>标签的<code>currentColor</code>自然也跟<code>color</code>值一样，为黑色，纯黑的<code>#000</code>。</p>
<h1 id="如何用？">如何用？</h1><p>了解它是怎样的物品后，下面问题来了，如何用？有额外的<code>buff</code>效果么，耗蓝多么，CD时间长么。。。</p>
<p>前面说道，它就是一个CSS变量，存储了颜色值，这个值来自当前元素的<code>color</code>CSS属性。当你需要为该元素其他属性指定颜色的时候，它就可以登上舞台了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line">    好好说话，有话好好说</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="class">.container</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#3CAADB</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">4px</span> solid currentColor</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><pre class="_cssdeck_embed" data-pane="output" data-user="wayou" data-href="wkwhomt3" data-version="0"></pre><script async src="http://cssdeck.com/assets/js/embed.js"></script></p>
<p>这里我们第一次领略了<code>currentColor</code>的奇效。在指定边框颜色的时候，我们直接使用<code>currentColor</code>变量，而没有写一个传统的颜色值。</p>
<p>你似乎也知道了该如何用了。不只是<code>border</code>，其他能够使用颜色的地方，比如<code>background</code>，<code>box-shadow</code>等等。</p>
<h1 id="带你装逼带你飞">带你装逼带你飞</h1><p>新技能就是如此炫酷。大开脑洞任性地去使用吧！</p>
<h2 id="与渐变混搭">与渐变混搭</h2><p>你可能无法想象到的是，除了可以将<code>currentColor</code>用到普通需要颜色的场景，它同样可以被用在渐变中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="class">.container</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">200px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#3CAADB</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">linear-gradient</span>(to right, <span class="hexcolor">#fff</span>, currentColor <span class="number">100%</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><pre class="_cssdeck_embed" data-pane="output" data-user="wayou" data-href="igvks1h5" data-version="0"></pre><script async src="http://cssdeck.com/assets/js/embed.js"></script></p>
<p>甚至也可用于填充svg，下面会有相应示例。</p>
<h2 id="与CSS动画结合">与CSS动画结合</h2><p>当与CSS <code>animation</code>结合，可以得到更加有创意的效果，比如<a href="http://codepen.io/scottkellum/pen/Fhxql" target="_blank" rel="external">这个来自codepen的示例</a></p>
<p></p><p data-height="268" data-theme-id="2997" data-slug-hash="Fhxql" data-default-tab="result" data-user="scottkellum" class="codepen">See the Pen <a href="http://codepen.io/scottkellum/pen/Fhxql/" target="_blank" rel="external">currentColor</a> by Scott Kellum (<a href="http://codepen.io/scottkellum" target="_blank" rel="external">@scottkellum</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<h2 id="更加简洁的CSS">更加简洁的CSS</h2><p>其实，新技能不只是装逼那么单纯，合理的使用<code>currentColor</code> 变量会让你的CSS代码变得简洁。这才是我们想要达到的目的。以炫技为目的技能是没有生产意义的。</p>
<p>看下面这个例子（这个示例灵感来自<a href="http://osvaldas.info/keeping-css-short-with-currentcolor" target="_blank" rel="external">这里</a>）</p>
<p><img src="/asset/posts/2014-12-07-css-currentColor/btn_with_svg_st.jpg" alt="btn_with_svg_st"></p>
<p>我们在按钮中使用了一个svg图标。你是一个负责任的FE，所以，对这个按钮的各种状态<code>:focus</code>，<code>:hover</code>，<code>:active</code>都作了样式上的处理。同时，为了让图标也跟着保持一致的姿态变更，需要把对<code>&lt;a&gt;</code>标签的样式处理同样就到到<code>&lt;svg&gt;</code>标签上。于是你的CSS代码看起来就是下面这样的了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*a 标签*/</span></span><br><span class="line"><span class="class">.button</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#117B6F</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1.2em</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="rule"><span class="attribute">.button</span>:<span class="value">hover, .button:focus &#123;</span><br><span class="line">    color: <span class="hexcolor">#01B19A</span></span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="rule"><span class="attribute">.button</span>:<span class="value">active &#123;</span><br><span class="line">    color: <span class="hexcolor">#02D7BB</span></span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*svg 标签*/</span></span><br><span class="line"><span class="class">.button</span> <span class="tag">svg</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">17px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">17px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">fill</span>:<span class="value"> <span class="hexcolor">#117B6F</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="rule"><span class="attribute">.button</span>:<span class="value">hover svg, .button:focus svg &#123;</span><br><span class="line">    fill: <span class="hexcolor">#01B19A</span></span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="rule"><span class="attribute">.button</span>:<span class="value">active svg &#123;</span><br><span class="line">    fill: <span class="hexcolor">#02D7BB</span></span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><pre class="_cssdeck_embed" data-pane="output" data-user="wayou" data-href="smxdd6mn" data-version="0"></pre><script async src="http://cssdeck.com/assets/js/embed.js"></script></p>
<p>你也发现了，代码有点冗余。接下来，我们用<code>currentColor</code>来将它简化一下。于是成了下面这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*a 标签*/</span></span><br><span class="line"><span class="class">.button</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#117B6F</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1.2em</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="rule"><span class="attribute">.button</span>:<span class="value">hover, .button:focus &#123;</span><br><span class="line">    color: <span class="hexcolor">#01B19A</span></span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="rule"><span class="attribute">.button</span>:<span class="value">active &#123;</span><br><span class="line">    color: <span class="hexcolor">#02D7BB</span></span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*svg 标签*/</span></span><br><span class="line"><span class="class">.button</span> <span class="tag">svg</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">17px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">17px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">fill</span>:<span class="value"> currentColor</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><pre class="_cssdeck_embed" data-pane="output" data-user="wayou" data-href="oxuuu1ex" data-version="0"></pre><script async src="http://cssdeck.com/assets/js/embed.js"></script></p>
<h2 id="更好维护的CSS">更好维护的CSS</h2><p>仔细想想不难发现，当使用<code>currentColor</code>后，我们的CSS也变得更加好维护了。</p>
<p>还拿上面的按钮示例来说，优化之前不但代码冗余，而且哪天PM来劲了说这颜色饱看，给换个其他色。于是你得把<code>&lt;a&gt;</code>标签和<code>&lt;svg&gt;</code>一起换了。</p>
<p>但优化后就不一样了，因为<code>&lt;svg&gt;</code>使用的填充是<code>currentColor</code>，你只需要改变<code>&lt;a&gt;</code>标签的颜色，它也就跟着变了。真正做到了牵一发而不动全身。这不正是众码友们毕生所追求的理想编程境界么。</p>
<h1 id="浏览器兼容性">浏览器兼容性</h1><p>一提到浏览器兼容性，FE同学们或许就不敢那么任性了。之前你可能是这样的：</p>
<p><img src="/asset/posts/2014-12-07-css-currentColor/before.gif" alt="before"></p>
<p>当听到IE传来的噩耗，你可能是这样的：</p>
<p><img src="/asset/posts/2014-12-07-css-currentColor/after.gif" alt="after"></p>
<p>经查，<a href="http://caniuse.com/#search=currentcolor" target="_blank" rel="external">can i use</a> 没有关于它的数据。</p>
<p>经测，</p>
<ul>
<li>本机Win7搭载的IE8不支持</li>
<li>本机安装的火狐31发来战报表示支持</li>
<li>Chrome，你猜？</li>
<li>本机Safari 5.1.7也表示支持</li>
<li>本机Opera 26 同样表示支持</li>
</ul>
<p>根据<a href="http://demosthenes.info/blog/908/The-First-CSS-Variable-currentColor" target="_blank" rel="external">这篇文章</a>的描述，它是可以很好地工作在在所有现代浏览器和IE9+上的，甚至是各浏览器对应的移动版本。所以，在IE不是主要客户对象的情况下，还是可以放心使用的。</p>
<h1 id="参考">参考</h1><ul>
<li><a href="http://css-tricks.com/currentcolor/" target="_blank" rel="external">css-tricks currentColor</a></li>
<li><a href="http://osvaldas.info/keeping-css-short-with-currentcolor" target="_blank" rel="external">Keeping CSS short with currentColor</a></li>
<li><a href="http://demosthenes.info/blog/908/The-First-CSS-Variable-currentColor" target="_blank" rel="external">The First CSS Variable: currentColor</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>CSS中存在一个神秘的变量，少有人知自然也不怎么为人所用。它就是<code>crrentColor</code>变量（或者说是CSS关键字，但我觉得称为变量好理解些）。</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://wayou.github.io/tags/CSS/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML5 <details> 标签]]></title>
    <link href="http://wayou.github.io/2014/11/30/html5-details-tag/"/>
    <id>http://wayou.github.io/2014/11/30/html5-details-tag/</id>
    <published>2014-11-30T12:54:43.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<p>HTML5 中新增的<code>&lt;details&gt;</code>标签允许用户创建一个可展开折叠的元件，让一段文字或标题包含一些隐藏的信息。</p>
<a id="more"></a>
<h1 id="用法">用法</h1><p>一般情况下，<code>details</code>用来对显示在页面的内容做进一步骤解释。其展现出来的效果和jQuery手风琴插件差不多。</p>
<p>其大致写法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">summary</span>&gt;</span>Google Nexus 6<span class="tag">&lt;/<span class="title">summary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>商品详情：<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dt</span>&gt;</span>屏幕<span class="tag">&lt;/<span class="title">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dd</span>&gt;</span>5.96” 2560x1440 QHD AMOLED display (493 ppi)<span class="tag">&lt;/<span class="title">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dt</span>&gt;</span>电池<span class="tag">&lt;/<span class="title">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dd</span>&gt;</span>3220 mAh<span class="tag">&lt;/<span class="title">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dt</span>&gt;</span>相机<span class="tag">&lt;/<span class="title">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dd</span>&gt;</span>13MP rear-facing with optical image stabilization 2MP front-facing<span class="tag">&lt;/<span class="title">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dt</span>&gt;</span>处理器<span class="tag">&lt;/<span class="title">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dd</span>&gt;</span>Qualcomm® Snapdragon™ 805 processor<span class="tag">&lt;/<span class="title">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">details</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先是<code>&lt;details&gt;</code>标签，里面接着是标题<code>&lt;summary&gt;</code>，这里面的内容一般简短，具有总结性，会展示在页面。接着可以跟任意类型的HTML元素作为详情内容，这些内容需要在点击<code>&lt;summary&gt;</code>才会呈现。</p>
<p>上面代码呈现出来的效果会是下面这样的：</p>
<p><img src="/asset/posts/2014-11-30-html5-details-tag/html5_details_tag.gif" alt="html5 details tag"></p>
<p>最开始详情是隐藏的，当点击时都会展现。</p>
<h2 id="open_属性">open 属性</h2><p>当然，你也可以通过给<code>&lt;details&gt;</code>标签设置<code>open</code>属性让它默认为展开状态。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">details</span> <span class="attribute">open</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">summary</span>&gt;</span>Google Nexus 6<span class="tag">&lt;/<span class="title">summary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>商品详情：<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dt</span>&gt;</span>屏幕<span class="tag">&lt;/<span class="title">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dd</span>&gt;</span>5.96” 2560x1440 QHD AMOLED display (493 ppi)<span class="tag">&lt;/<span class="title">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dt</span>&gt;</span>电池<span class="tag">&lt;/<span class="title">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dd</span>&gt;</span>3220 mAh<span class="tag">&lt;/<span class="title">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dt</span>&gt;</span>相机<span class="tag">&lt;/<span class="title">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dd</span>&gt;</span>13MP rear-facing with optical image stabilization 2MP front-facing<span class="tag">&lt;/<span class="title">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dt</span>&gt;</span>处理器<span class="tag">&lt;/<span class="title">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dd</span>&gt;</span>Qualcomm® Snapdragon™ 805 processor<span class="tag">&lt;/<span class="title">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">details</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时默认会把详情展开，而点击标题后会折叠起来。</p>
<h1 id="示例">示例</h1><p>示例如上面那样，预览在线版本可<a href="http://sandbox.runjs.cn/show/hjotymth" target="_blank" rel="external">点击此处</a>。</p>
<h1 id="浏览器兼容性">浏览器兼容性</h1><p>由于是HTML5新标签，浏览器支持情况不是很理想。从来自<a href="http://caniuse.com/#feat=details" target="_blank" rel="external">caniuse</a>的数据来看，目前仅Chrome, Safari 8+ 和Opera 26+支持此标签。</p>
<p>可喜的是，如果你在caniuse开启了「显示来自UC浏览器的结果」 选项的话，会发现，国产的UC浏览器也支持了此标签。</p>
<p><img src="/asset/posts/2014-11-30-html5-details-tag/browser_compatability.jpg" alt="can i use details tag"></p>
<h1 id="Polyfill">Polyfill</h1><p>既然支持情况如此不理解，那么使用垫片（polyfill）就很有必要了。</p>
<p>垫片就是在那些不支持此特性的浏览器上使用JavaScript来手动模拟，看起来好像是浏览器支持了一样。</p>
<p><a href="http://www.smashingmagazine.com/author/maksim-chemerisuk/?rel=author" target="_blank" rel="external">chemerisuk</a>给出了他的一个实现，源码在<a href="https://github.com/chemerisuk/better-
[details-polyfill" target="_blank" rel="external">GitHub上</a>，具体的实现思路也写成了博文发到了<a href="http://www.smashingmagazine.com/2014/11/28/complete-polyfill-html5-details-element/" target="_blank" rel="external">Smashing Magazine</a>，用法可参见GitHub。</p>
<h1 id="参考">参考</h1><ul>
<li><a href="http://www.w3schools.com/tags/tag_details.asp" target="_blank" rel="external">HTML &lt;details&gt; Tag</a></li>
<li><a href="http://www.w3schools.com/tags/tag_dt.asp" target="_blank" rel="external">HTML &lt;dt&gt; Tag</a></li>
<li><a href="http://www.smashingmagazine.com/2014/11/28/complete-polyfill-html5-details-element/" target="_blank" rel="external">Making A Complete Polyfill For The HTML5 Details Element</a></li>
<li><a href="https://github.com/chemerisuk/better-details-polyfill" target="_blank" rel="external">better-details-polyfill</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>HTML5 中新增的<code>&lt;details&gt;</code>标签允许用户创建一个可展开折叠的元件，让一段文字或标题包含一些隐藏的信息。</p>]]>
    
    </summary>
    
      <category term="html5" scheme="http://wayou.github.io/tags/html5/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript的基准测试-不服跑个分？]]></title>
    <link href="http://wayou.github.io/2014/11/26/javascript-benchmarking/"/>
    <id>http://wayou.github.io/2014/11/26/javascript-benchmarking/</id>
    <published>2014-11-26T19:54:36.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="https://mathiasbynens.be/notes/javascript-benchmarking" target="_blank" rel="external">Bulletproof JavaScript benchmarks</a></p>
</blockquote>
<p>做JavaScript的基准测试并没有想的那么简单。即使不考虑浏览器差异所带来的影响，也有很多难点——或者说陷阱需要面对。</p>
<a id="more"></a>
<p>这是为何我创建了<a href="http://jsperf.com/" target="_blank" rel="external">jsPerf</a>的一个原因，一个你可以轻松创建并分享各种代码片段对比结果的简单工具。用起来非常省事，只需把想要测试的代码录入然后jsPerf会为你创建好可以跨平台跑起来的测试用例。</p>
<p>内部实现上，最开始jsPerf用的是一个基于<a href="http://www.broofa.com/Tools/JSLitmus/" target="_blank" rel="external">JSLitmus</a>的基准测试库，我将它称作<a href="http://benchmarkjs.com/" target="_blank" rel="external">Benchmark.js</a>。后续又往里面添加了更多的特性，最近，<a href="http://allyoucanleet.com/" target="_blank" rel="external">John-David Dalton</a>干脆将这个库彻底重写了一遍。所以现在Benchmark.js已经比之前好很多了。</p>
<p>本文将对JavaScript基准测试的编写和运行有一定的参考意义。</p>
<h1 id="基准测试的类型">基准测试的类型</h1><p>有很多方法可以测试一段JavaScript代码的性能。最常见的做法是类似下面这样的：</p>
<h2 id="方案A">方案A</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> totalTime,</span><br><span class="line">    start = <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">    iterations = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">while</span> (iterations--) &#123;</span><br><span class="line">  <span class="comment">// 被测试的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// totalTime → 运行该测试代码6次需要的时间（单位：毫秒）</span></span><br><span class="line">totalTime = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</span><br></pre></td></tr></table></figure>
<p>这种方案将被测试的代码循环执行多次直到预设值（本例为6次）。最后用结束时的时间减去开始的时间，得到运行的总时间。</p>
<p> 方案A被用于<a href="https://github.com/kamicane/slickspeed/" target="_blank" rel="external">SlickSpeed</a>, <a href="https://github.com/phiggins42/taskspeed" target="_blank" rel="external">Taskspeed</a>, <a href="http://www2.webkit.org/perf/sunspider/sunspider.html" target="_blank" rel="external">SunSpider</a>, 和 <a href="http://krakenbenchmark.mozilla.org/" target="_blank" rel="external">Kraken</a>这些流行的基准测试库中。</p>
<h2 id="缺憾">缺憾</h2><p> 鉴于现在的设备和浏览器运行得越来越快，这种将代码运行固定次数的测试方法有很大概念会得到一个0ms的时间差结果，显然0是毫无意义的。</p>
<h2 id="方案B">方案B</h2><p>另一种方案是计算固定时间内进行了多少运算量。较之前的做法，这回你不用指定一个固定的循环次数了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hz,</span><br><span class="line">    period,</span><br><span class="line">    startTime = <span class="keyword">new</span> <span class="built_in">Date</span>,</span><br><span class="line">    runs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 被测试的代码</span></span><br><span class="line">  runs++;</span><br><span class="line">  totalTime = <span class="keyword">new</span> <span class="built_in">Date</span> - startTime;</span><br><span class="line">&#125; <span class="keyword">while</span> (totalTime &lt; <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将毫秒转为秒</span></span><br><span class="line">totalTime /= <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// period → 单位运算的耗时</span></span><br><span class="line">period = totalTime / runs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hz → 单位时间（1秒）内进行的运算量</span></span><br><span class="line">hz = <span class="number">1</span> / period;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面两步可以简写如下：</span></span><br><span class="line"><span class="comment">// hz = (runs * 1000) / totalTime;</span></span><br></pre></td></tr></table></figure>
<p>将测试代码一直循环运行直到总耗时<code>totalTime</code> 大于等于1000毫秒，也就是1秒种。</p>
<p>方案B 用于<a href="http://dromaeo.com/" target="_blank" rel="external">Dromaeo</a>和<a href="http://code.google.com/apis/v8/benchmarks.html" target="_blank" rel="external">V8 Benchmark Suite</a>这两个库。</p>
<h2 id="不足">不足</h2><p>由于有垃圾回收，(运行时的)引擎对代码的动态优化以及其他进程等的影响，此方案在重复进行测试时得到的结果不尽相同。为了得到更精确的测试结果，需要多次测试取均值。而上面提到的V8 库只会对测试运行一次，Dromaeo 则会运行5次，但其实还可以做得更彻底以获取更加精准的结果。一个可行的途径就是想办法将目前的测试时间由1000毫秒压缩到50毫秒，当然前提是系统提供给我们一个没有误差且绝对精确的时钟，这能保证时间尽可能多地用于运行测试代码（而不会过多地被操作系统的中间停顿浪费掉）。</p>
<h2 id="方案_C">方案 C</h2><p>JSLitmus 这个库结合了前面两种方案的优点。采用方案A 来将测试代码运行<code>n</code>次，同时动态调整这个<code>n</code>值以保证测试能够进行到一个最小的时长，也就是方案B所描述的那样。</p>
<h2 id="症结">症结</h2><p>JSLitmus 规避了方案A的缺点但同时引入了方案B的不足之处。为了进一步提高测试的准确率，JSLitmus 将结果进行了量化，取出3次空测试（译注：不太理解这里的<code>空测试</code>为何物，不挂测试代码空跑？？）中运行最快的一次，再将每次基准测试的结果减去这个最快值。不幸的是这种做法为了规避B方案的毛病（译注：B方案需要运行多次以得到更多采样集合以取均值，换句话说要得到越准确的结果就要耗费越多的时间）反而使结果更不可靠了，因为取3次中最快的一次本身就不符合统计规律（译注：按统计学的做法，为了得到3次中最快的一次结果，这里又需要运行另外的测试来拿到一个所谓的最快的结果的集合，然后从中求均值）。尽管JSLitmus可以多次运行这样的基准测试，将量化后的均值与每次测试结果的均值进行差额运算，但这样得到的最终结果其身上的误差已经足够掩盖之前我们为了提高准确率而做的任何努力了。</p>
<h2 id="方案_D">方案 D</h2><p>前面三种方案的短肋可以通过方法转编(<code>function compilation</code> 编译转化之意)和循环展开(loop unrolling)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x == y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterations--) &#123;</span><br><span class="line">  test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// …将会编译转化为 →</span></span><br><span class="line"><span class="keyword">var</span> hz,</span><br><span class="line">    startTime = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">x == y;</span><br><span class="line">x == y;</span><br><span class="line">x == y;</span><br><span class="line">x == y;</span><br><span class="line">x == y;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"></span><br><span class="line">hz = (runs * <span class="number">1000</span>) / (<span class="keyword">new</span> <span class="built_in">Date</span> - startTime);</span><br></pre></td></tr></table></figure>
<p>这种做法将测试代码<a href="http://en.wikipedia.org/wiki/Loop_unwinding" target="_blank" rel="external">变成了展开的形式</a>，避免了循环和量化工作(译注：没有了循环也就无需统计单位时间内的运算量了)。</p>
<h2 id="问题">问题</h2><p>然而，纵然如此它还是有不足之处的。将函数转编会消耗大量内存同时也把CPU拖慢。当你把一个测试跑上几百万次时，可以想象到会创建大量的字符串和转编无数的函数。</p>
<p>这还不算，因为一个函数完全有可能在遇到<code>return</code>后提前结束执行。所以如果测试中函数在第3行就返回了，将循环展开成上百万的代码就显得毫无意义。看来检测这些可能的提前退出还是很有必要的，然后回归到使用<code>while</code>语句（也就是方案A的做法）加上对循环结果的量化。</p>
<h2 id="函数体的提取">函数体的提取</h2><p>在Benchmark.js的实现中，使用了一个稍微不同的做法。你可以认为它结合了方案A,B,C还有D的长处。考虑到内存因素，我们没有将循环展开。为了控制住增大结果误差的因素，同时又让测试代码可以使用较为自然的实现和变量，我们将每个测试代码的函数体提取出来。譬如，当用下面的代码进行测试时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>,</span><br><span class="line">    y = <span class="string">'1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x == y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterations--) &#123;</span><br><span class="line">  test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// …转会转编为 →</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>,</span><br><span class="line">    y = <span class="string">'1'</span>;</span><br><span class="line"><span class="keyword">while</span> (iterations--) &#123;</span><br><span class="line">  x == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来，Benchmark.js 使用一个与 JSLitmus近似的技术：将提取出来的函数体放到一个循环中（这是方案A的做法），重复执行直到达到一个最小的时限（这是方案B），最后重复整个流程取一个严格意义上的统计均值作为结果。</p>
<h1 id="注意事项">注意事项</h1><h2 id="有偏差的毫秒时钟">有偏差的毫秒时钟</h2><p>某些浏览器与操作系统的组合中，由于<a href="http://msdn.microsoft.com/en-us/windows/hardware/gg463347.aspx" target="_blank" rel="external">种种</a><a href="http://alivebutsleepy.srnet.cz/unreliable-system-nanotime/" target="_blank" rel="external">因素</a>存在时钟不准的情况。</p>
<p>例如：</p>
<blockquote>
<p>Windows XP开机后，程序执行的时钟周期为 10毫秒，这在其他操作系统中一般为15毫秒。意思就是每隔10毫秒操作系统会接收到来自硬件（译注：也就是CPU的时钟系统）的一次中断。</p>
</blockquote>
<p>一些很老的浏览器（IE或者火狐2）严重依赖操作系统的时钟，也就是说每次你调用<code>new Date().getTime()</code>它其实直接从系统那里去拿这个时间。很显然，如果内部系统的时间都只间隔10毫秒或者15毫秒才更新一次，那测试结果会受很大影响，准确性大大降低。这个问题是需要解决的。</p>
<p>值得庆幸的是，JavaScript是可以<a href="https://mathiasbynens.be/demo/javascript-timers" target="_blank" rel="external">拿到最小的时间度量单位</a>的。这之后，我们可以通过<a href="http://spiff.rit.edu/classes/phys273/uncert/uncert.html" target="_blank" rel="external">数学方式</a>将测试结果的不确定性降低到只有1%。为此，我们将这个最小时间度量单位除以2以得到这个<em>不确定性</em>的值。假设我们在XP上用IE6，此种情况下最小的度量单位是15毫秒。这个不确定性的值就为<code>15ms/2=7.5ms</code>。然后我们想控制结果的误差到1%，于是乎我们将刚才得到的不确定性值除以0.01，就得到了达到测试要求需要的最小测试时限为：<code>7.5/0.01=750ms</code>。</p>
<h2 id="备选时钟">备选时钟</h2><p>当启用<code>--enable-benchmarking</code> 标志后，Chrome和Chromium会暴露出一个叫做<code>chrome.Interval</code>的方法，可以用它作为一个高精度的时钟。</p>
<p>在编写Benchmark.js库时， John-David Dalton 经过一番折腾后将Java里这个纳秒级的时钟通过一个小的Java applet插件暴露到了JavaScript中。</p>
<p>使用更高精度的时钟可以缩短测试周期，相应地可以跑更多测试样本，从而得到一个误差更小的测试结果。</p>
<h2 id="Firebug_会禁用火狐的_JIT">Firebug 会禁用火狐的 JIT</h2><p>启用Firebug后会禁用火狐高性能的实时(just-in-time <a href="http://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="external">JIT</a>)本地代码编译，然后你的代码会跑在普通的JavaScript解释器里面。这将会比原先慢很多。所以在跑基准测试时千万记得关掉Firebug。</p>
<p>其他浏览器的元素审查工具比如WebKit的<code>Web Inspector</code>或者欧朋浏览器的<code>Dragonfly</code>在开启时也有类似问题，尽管相比于上面的情况会小很多。所以在跑测试时最好还是关掉这些，或多或少还是会影响测试结果的。</p>
<h2 id="浏览器缺陷和特性">浏览器缺陷和特性</h2><p>基准测试内部实现中的一些循环机制容易受到一些浏览器本身缺陷的影响，比如像最近IE9的<a href="http://www.zdnet.com/blog/bott/ie9-takes-top-benchmark-prize-no-cheating-involved/2671" target="_blank" rel="external">dead-code-removal</a>展示的那样。<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=509069" target="_blank" rel="external">火狐<code>TraceMonkey</code> 引擎</a>的一个bug，还有欧朋11 <a href="http://jsperf.com/jquery-css3-not-vs-not" target="_blank" rel="external">对<code>querySelectorAll</code>结果的缓存</a>都会影响到测试结果。这些都是在进行测试是需要注意的。</p>
<h2 id="统计学的重要性">统计学的重要性</h2><p>大多数的基准测试/测试代码给出的结果并且没有严格符合统计学要求。John Resig（译注：jQuery原始作者）在他早前的一篇文章「<a href="http://ejohn.org/blog/javascript-benchmark-quality/" target="_blank" rel="external">JavaScript 基准测试的质量</a>」中有提到。简单来说，就是应该尽量考虑到每个测试结果的误差并去减小它。扩大测试的样本值，健全的测试执行，都能够起到减少误差的作用。</p>
<h2 id="跨浏览器的测试">跨浏览器的测试</h2><p>如果你想在不同浏览器中进行测试且想得到较可靠的结果，一定要在真实的浏览器中测试。不要依赖于IE自带的兼容模式，此模式跟他<a href="http://jsperf.com/join-concat#comments" target="_blank" rel="external">所模拟的版本是存在实质性差异</a>的。</p>
<p>还有就是除了跟大多其他浏览器一样会限制脚本的时间，IE(8及以下)还限制了代码的指令数不能超过5百万。事实上以现在CPU的吞吐能力，这样的数量级处理起来只是半秒钟的事情。如果你配置确实过硬，跑起来倒也没什么只是IE会给出一个<code>Script Warning</code>的警告，这种情况下你可以通过修改注册表来增大这个数量限制。幸运的是微软还提供了一个<a href="http://go.microsoft.com/?linkid=9729250" target="_blank" rel="external">修复助手的程序</a>，你只需要运行即可，比修改注册表方便多了。更可喜的是，IE9以上，这个逗逼的限制被移除了。</p>
<h1 id="总结">总结</h1><p>无论你只是跑了一些测试，或者写一些用例，抑或正在自己写一个基准测试库，关于JavaScript基准测试的奥义远比你看到得要多（译注：就是水很深，并不是跑个分那么简单）。Benchmark.js和jsPerf<a href="https://github.com/bestiejs/benchmark.js/commits/master" target="_blank" rel="external">每周都有更新</a>，包含bug修复，新功能添加和一些提升准确率的技巧。但愿主流浏览器也能够为此做些努力吧…</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>原文：<a href="https://mathiasbynens.be/notes/javascript-benchmarking">Bulletproof JavaScript benchmarks</a></p>
</blockquote>
<p>做JavaScript的基准测试并没有想的那么简单。即使不考虑浏览器差异所带来的影响，也有很多难点——或者说陷阱需要面对。</p>]]>
    
    </summary>
    
      <category term="benchmark" scheme="http://wayou.github.io/tags/benchmark/"/>
    
      <category term="javascript" scheme="http://wayou.github.io/tags/javascript/"/>
    
      <category term="性能" scheme="http://wayou.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[延迟求值-如何让Lo-Dash再提速x100?]]></title>
    <link href="http://wayou.github.io/2014/11/08/lazy-evaluation/"/>
    <id>http://wayou.github.io/2014/11/08/lazy-evaluation/</id>
    <published>2014-11-08T15:29:27.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>「注释」作者在本文里没有说明这么一个事实：<br>目前的版本<code>Lo-Dash v2.4.1</code>并没有引入延迟求值的特性，<code>Lo-Dash 3.0.0-pre</code>中部分方法进行了引入，比如<code>filter()</code>,<code>map()</code>,<code>reverse()</code>。</p>
<p>原文：<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation" target="_blank" rel="external">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a></p>
</blockquote>
<p>我时常觉得像<code>Lo-Dash</code>这样优秀的库已经无法再优化了。它整合了各种<a href="https://www.youtube.com/watch?v=NthmeLEhDDM" target="_blank" rel="external">奇技淫巧</a>已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。</p>
<a id="more"></a>
<h1 id="延迟求值">延迟求值</h1><p>但似乎我错了-还可以让<code>Lo-Dash</code>有明显的提升。只需将关注点从细微的优化转移到算法上来。譬如，在一次循环中我们往往会去优化循环体：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> len = getLength();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    operation(); <span class="comment">// &lt;- 10ms - 如何做到 9ms?!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但针对循环体的优化往往很难，很多时候已经到极限了。相反，优化<code>getLength()</code> 函数尽量减少循环次数变得更有意义了。你想啊，这个数值越小，需要循环的<code>10ms</code>就越少。</p>
<p>这便是<code>Lo-Dash</code>实现延迟求值的大致思路。重要的是减少循环次数，而不是每次循环的时间。让我们考察下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">priceLt</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123; <span class="keyword">return</span> item.price &lt; x; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gems = [</span><br><span class="line">   &#123; name: <span class="string">'Sunstone'</span>, price: <span class="number">4</span> &#125;, &#123; name: <span class="string">'Amethyst'</span>, price: <span class="number">15</span> &#125;,</span><br><span class="line">   &#123; name: <span class="string">'Prehnite'</span>, price: <span class="number">20</span>&#125;, &#123; name: <span class="string">'Sugilite'</span>, price: <span class="number">7</span>  &#125;,</span><br><span class="line">   &#123; name: <span class="string">'Diopside'</span>, price: <span class="number">3</span> &#125;, &#123; name: <span class="string">'Feldspar'</span>, price: <span class="number">13</span> &#125;,</span><br><span class="line">   &#123; name: <span class="string">'Dioptase'</span>, price: <span class="number">2</span> &#125;, &#123; name: <span class="string">'Sapphire'</span>, price: <span class="number">20</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chosen = _(gems).filter(priceLt(<span class="number">10</span>)).take(<span class="number">3</span>).value();</span><br></pre></td></tr></table></figure>
<p>我们只想取出3个价格低于10元的小球。通常情况下我们先过滤整个数据源，最后从所有小于10的元素里返回前面三个即可。</p>
<p><img src="/asset/posts/2014-11-08-lazy-evaluation/lodash-naive.gif" alt="lo-dash naive"></p>
<p>但这种做法并不优雅。它处理了全部8个数据，但其实只需要处理前面5个我们就能拿到结果了。同样为了得到正确的结果，延迟求值则只处理最少的元素。优化后如下图所示：</p>
<p><img src="/asset/posts/2014-11-08-lazy-evaluation/grafika.gif" alt="lo-dash naive"></p>
<p>一下子就获得了37.5%的性能提升。很容易找出提升X1000+的例子。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> phoneNumbers = [<span class="number">5554445555</span>, <span class="number">1424445656</span>, <span class="number">5554443333</span>, … ×<span class="number">99</span>,<span class="number">999</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出100个含 `55` 的号码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains55</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.contains(<span class="string">"55"</span>); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = _(phoneNumbers).map(<span class="built_in">String</span>).filter(contains55).take(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子中<code>map</code>和<code>filter</code> 将遍历99999 个元素，但很有可能我们只需处理到1000个元素的时候就已经拿到想要的结果了。这回性能的提升就太明显了（<a href="http://jsperf.com/lazy-demo" target="_blank" rel="external">benchmark</a>）：</p>
<p><img src="/asset/posts/2014-11-08-lazy-evaluation/benchmark.jpg" alt="benchmark"></p>
<h1 id="流水线">流水线</h1><p>延迟求值同时带来了另一个好处，我称之为“流水线”。要旨就是避免产生中间数组，而是对一个元素一次性进行完所有操作。下面用代码说话：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = _(source).map(func1).map(func2).map(func3).value();</span><br></pre></td></tr></table></figure>
<p>上面看似优雅的写法在原始的<code>Lo-Dash</code>里会转换成下面的样子（直接求值）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [], temp1 = [], temp2 = [], temp3 = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">   temp1[i] = func1(source[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">   temp2[i] = func2(temp1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">   temp3[i] = func3(temp2[i]);</span><br><span class="line">&#125;</span><br><span class="line">result = temp3;</span><br></pre></td></tr></table></figure>
<p>当引入了延迟求值后，代码大致就成这样的了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">   result[i] = func3(func2(func1(source[i])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少不必要的中间变量多少会带来性能上的提升，特别是在数据源特别巨大，内存又吃紧的情况下。</p>
<h1 id="延迟执行">延迟执行</h1><p>延迟求值带来的另一个好处是延迟执行。无论何时你写了段链式代码，只有在显式地调用了<code>.value()</code>后才会真正执行。这样一来，在数据源需要异步去拉取的情况下，可以保证我们处理的是最新的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wallet = _(assets).filter(ownedBy(<span class="string">'me'</span>))</span><br><span class="line">                      .pluck(<span class="string">'value'</span>)</span><br><span class="line">                      .reduce(sum);</span><br><span class="line"></span><br><span class="line">$json.get(<span class="string">"/new/assets"</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    assets.push.apply(assets, data); <span class="comment">// 更新数据源</span></span><br><span class="line">    wallet.value(); <span class="comment">// 返回的结果是最新的</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>而且这种机制在某些情况下也会提高执行效果。我们可以老早发送一个请求获取数据，然后指定一个精确的时间来执行。</p>
<h1 id="后记">后记</h1><p>延迟求值并且不算什么新技术。在一些库中已经在使用了，比如<a href="http://en.wikipedia.org/wiki/Language_Integrated_Query" target="_blank" rel="external">LINQ</a>,<a href="http://danieltao.com/lazy.js/" target="_blank" rel="external">Lazy.js</a>还有其他等等。那么问题来了，<code>Lo-Dash</code>存在的意义是啥？我想就是你仍然可以使用你熟悉的<code>Underscore</code> 接口但享受一个更高效的底层实现，不需要额外的学习成本，代码上面也不会有大的变动，只需稍加修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>「注释」作者在本文里没有说明这么一个事实：<br>目前的版本<code>Lo-Dash v2.4.1</code>并没有引入延迟求值的特性，<code>Lo-Dash 3.0.0-pre</code>中部分方法进行了引入，比如<code>filter()</code>,<code>map()</code>,<code>reverse()</code>。</p>
<p>原文：<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a></p>
</blockquote>
<p>我时常觉得像<code>Lo-Dash</code>这样优秀的库已经无法再优化了。它整合了各种<a href="https://www.youtube.com/watch?v=NthmeLEhDDM">奇技淫巧</a>已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://wayou.github.io/tags/JavaScript/"/>
    
      <category term="性能" scheme="http://wayou.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何开发一个简单的HTML5 Canvas 小游戏]]></title>
    <link href="http://wayou.github.io/2014/11/02/how-to-make-a-simple-html5-canvas-game-zh/"/>
    <id>http://wayou.github.io/2014/11/02/how-to-make-a-simple-html5-canvas-game-zh/</id>
    <published>2014-11-02T13:14:34.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="http://www.lostdecadegames.com/how-to-make-a-simple-html5-canvas-game/" target="_blank" rel="external">How to make a simple HTML5 Canvas game</a></p>
</blockquote>
<p>想要快速上手HTML5 Canvas小游戏开发？下面通过一个例子来进行手把手教学。（如果你怀疑我的资历， <a href="http://www.wizardslizard.com/" target="_blank" rel="external">A Wizard’s Lizard</a>这个游戏的半数以上开发是由我完成的）</p>
<a id="more"></a>
<p>我们直接来看源码里的<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/js/game.js" target="_blank" rel="external">game.js</a>,当然你也可以<a href="http://www.lostdecadegames.com/demos/simple_canvas_game/" target="_blank" rel="external">在线体验</a>一下游戏先。</p>
<h1 id="游戏截图">游戏截图</h1><p><img src="/asset/posts/how-to-make-a-simple-html5-canvas-game-zh/screenshot.jpg" alt="游戏截图"></p>
<h1 id="创建画布">创建画布</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the canvas</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">canvas.width = <span class="number">512</span>;</span><br><span class="line">canvas.height = <span class="number">480</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(canvas);</span><br></pre></td></tr></table></figure>
<p>首先我们需要创建一张<a href="https://developer.mozilla.org/en/canvas_tutorial" target="_blank" rel="external">画布</a>作为游戏的舞台。这里通过JS代码而不是直接在HTML里写一个<code>&lt;canvas&gt;</code>元素目的是要说明代码创建也是很方便的。有了画布后就可以获得它的上下文来进行绘图了。然后我们还设置了画布大小，最后将其添加到页面上。</p>
<h1 id="准备图片">准备图片</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背景图片</span></span><br><span class="line"><span class="keyword">var</span> bgReady = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> bgImage = <span class="keyword">new</span> Image();</span><br><span class="line">bgImage.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    bgReady = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">bgImage.src = <span class="string">"images/background.png"</span>;</span><br></pre></td></tr></table></figure>
<p>游戏嘛少不了图片的，所以我们先加载一些图片先。简便起见，这里仅创建简单的图片对象，而不是专门写一个类或者Helper来做图片加载。<code>bgReady</code>这个变量用来标识图片是否已经加载完成从而可以放心地使用了，因为如果在<a href="http://stackoverflow.com/questions/2923564/uncaught-error-index-size-err" target="_blank" rel="external">图片加载未完成情况下进行绘制是会报错</a>的。</p>
<p>整个游戏中需要用到的三张图片：<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/images/background.png" target="_blank" rel="external">背景</a>，<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/images/hero.png" target="_blank" rel="external">英雄</a>及<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/images/monster.png" target="_blank" rel="external">怪物</a>我们都用上面的方法来处理。</p>
<h1 id="游戏对象">游戏对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 游戏对象</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">    speed: <span class="number">256</span>, <span class="comment">// 每秒移动的像素</span></span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> monster = &#123;</span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> monstersCaught = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>现在定义一些对象将在后面用到。我们的<code>英雄</code>有一个<code>speed</code>属性用来控制他每秒移动多少像素。<code>怪物</code>游戏过程中不会移动，所以只有坐标属性就够了。<code>monstersCaught</code>则用来存储怪物被捉住的次数。</p>
<h1 id="处理用户的输入">处理用户的输入</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理按键</span></span><br><span class="line"><span class="keyword">var</span> keysDown = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">"keydown"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    keysDown[e.keyCode] = <span class="literal">true</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> keysDown[e.keyCode];</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>现在开始处理用户的输入(对初次接触游戏开发的前端同学来说，这部分开始可能就需要一些脑力了)。在前端开发中，一般是用户触发了点击事件然后才去执行动画或发起异步请求之类的，但这里我们希望游戏的逻辑能够更加紧凑同时又要及时响应输入。所以我们就把用户的输入先保存下来而不是立即响应。</p>
<p>为此，我们用<code>keysDown</code>这个对象来保存用户按下的键值(<code>keyCode</code>)，如果按下的键值在这个对象里，那么我们就做相应处理。</p>
<h1 id="开始一轮游戏">开始一轮游戏</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当用户抓住一只怪物后开始新一轮游戏</span></span><br><span class="line"><span class="keyword">var</span> reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    hero.x = canvas.width / <span class="number">2</span>;</span><br><span class="line">    hero.y = canvas.height / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的怪物随机放置到界面上</span></span><br><span class="line">    monster.x = <span class="number">32</span> + (<span class="built_in">Math</span>.random() * (canvas.width - <span class="number">64</span>));</span><br><span class="line">    monster.y = <span class="number">32</span> + (<span class="built_in">Math</span>.random() * (canvas.height - <span class="number">64</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>reset</code>方法用于开始新一轮和游戏，在这个方法里我们将英雄放回画布中心同时将怪物放到一个随机的地方。</p>
<h1 id="更新对象">更新对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新游戏对象的属性</span></span><br><span class="line"><span class="keyword">var</span> update = <span class="function"><span class="keyword">function</span> (<span class="params">modifier</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">38</span> <span class="keyword">in</span> keysDown) &#123; <span class="comment">// 用户按的是↑</span></span><br><span class="line">        hero.y -= hero.speed * modifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">40</span> <span class="keyword">in</span> keysDown) &#123; <span class="comment">// 用户按的是↓</span></span><br><span class="line">        hero.y += hero.speed * modifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">37</span> <span class="keyword">in</span> keysDown) &#123; <span class="comment">// 用户按的是←</span></span><br><span class="line">        hero.x -= hero.speed * modifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">39</span> <span class="keyword">in</span> keysDown) &#123; <span class="comment">// 用户按的是→</span></span><br><span class="line">        hero.x += hero.speed * modifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 英雄与怪物碰到了么？</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        hero.x &lt;= (monster.x + <span class="number">32</span>)</span><br><span class="line">        &amp;&amp; monster.x &lt;= (hero.x + <span class="number">32</span>)</span><br><span class="line">        &amp;&amp; hero.y &lt;= (monster.y + <span class="number">32</span>)</span><br><span class="line">        &amp;&amp; monster.y &lt;= (hero.y + <span class="number">32</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">        ++monstersCaught;</span><br><span class="line">        reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是游戏中用于更新画面的<code>update</code>函数，会被规律地重复调用。首先它负责检查用户当前按住的是中方向键，然后将英雄往相应方向移动。</p>
<p>有点费脑力的或许是这个传入的<code>modifier</code> 变量。你可以在<code>main</code> 方法里看到它的来源，但这里还是有必要详细解释一下。它是基于1开始且随时间变化的一个因子。例如1秒过去了，它的值就是1，英雄的速度将会乘以1，也就是每秒移动256像素；如果半秒钟则它的值为0.5，英雄的速度就乘以0.5也就是说这半秒内英雄以正常速度一半的速度移动。理论上说因为这个<code>update</code> 方法被调用的非常快且频繁，所以<code>modifier</code>的值会很小，但有了这一因子后，不管我们的代码跑得快慢，都能够保证英雄的移动速度是恒定的。</p>
<p>现在英雄的移动已经是基于用户的输入了，接下来该检查移动过程中所触发的事件了，也就是英雄与怪物相遇。这就是本游戏的胜利点，<code>monstersCaught</code> +1然后重新开始新一轮。</p>
<h1 id="渲染物体">渲染物体</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画出所有物体</span></span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bgReady) &#123;</span><br><span class="line">        ctx.drawImage(bgImage, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heroReady) &#123;</span><br><span class="line">        ctx.drawImage(heroImage, hero.x, hero.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (monsterReady) &#123;</span><br><span class="line">        ctx.drawImage(monsterImage, monster.x, monster.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计分</span></span><br><span class="line">    ctx.fillStyle = <span class="string">"rgb(250, 250, 250)"</span>;</span><br><span class="line">    ctx.font = <span class="string">"24px Helvetica"</span>;</span><br><span class="line">    ctx.textAlign = <span class="string">"left"</span>;</span><br><span class="line">    ctx.textBaseline = <span class="string">"top"</span>;</span><br><span class="line">    ctx.fillText(<span class="string">"Monsterrs caught: "</span> + monstersCaught, <span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之前的工作都是枯燥的，直到你把所有东西画出来之后。首先当然是<a href="https://developer.mozilla.org/en/Canvas_tutorial/Using_images" target="_blank" rel="external">把背景图画出来</a>。然后如法炮制将英雄和怪物也画出来。这个过程中的顺序是有讲究的，因为后画的物体会覆盖之前的物体。</p>
<p>这之后我们改变了一下<code>Canvas</code>的绘图上下文的样式并调用<code>fillText</code>来绘制文字，也就是记分板那一部分。本游戏没有其他复杂的动画效果和打斗场面，绘制部分大功告成！</p>
<h1 id="主循环函数">主循环函数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 游戏主函数</span></span><br><span class="line"><span class="keyword">var</span> main = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">var</span> delta = now - then;</span><br><span class="line"></span><br><span class="line">    update(delta / <span class="number">1000</span>);</span><br><span class="line">    render();</span><br><span class="line"></span><br><span class="line">    then = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即调用主函数</span></span><br><span class="line">    requestAnimationFrame(main);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的主函数控制了整个游戏的流程。先是拿到当前的时间用来计算时间差（距离上次主函数被调用时过了多少毫秒）。得到<code>modifier</code>后除以1000(也就是1秒中的毫秒数)再传入<code>update</code>函数。最后调用<code>render</code> 函数并且将本次的时间保存下来。</p>
<p>关于游戏中循环更新画面的讨论可参见「<a href="http://www.html5rocks.com/en/tutorials/casestudies/onslaught.html#toc-the-game-loop" target="_blank" rel="external"> Onslaught! Arena Case Study</a>」。</p>
<h1 id="关于循环的进一步解释">关于循环的进一步解释</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// requestAnimationFrame 的浏览器兼容性处理</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="built_in">window</span>;</span><br><span class="line">requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;</span><br></pre></td></tr></table></figure>
<p><em>如果你不是完全理解上面的代码也没关系，我只是觉得拿出来解释一下总是极好的</em></p>
<p>为了循环地调用<code>main</code>函数，本游戏之前用的是<code>setInterval</code>。但现今已经有了更好的方法那就是<code>requestAnimationFrame</code>。使用新方法就不得不考虑浏览器兼容性。上面的<a href="https://en.wikipedia.org/wiki/Polyfill" target="_blank" rel="external">垫片</a>就是出于这样的考虑，它是<a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="external">Paul Irish 博客原版</a>的一个简化版本。</p>
<h1 id="启动游戏！">启动游戏！</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 少年，开始游戏吧！</span></span><br><span class="line"><span class="keyword">var</span> then = <span class="built_in">Date</span>.now();</span><br><span class="line">reset();</span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<p>总算完成了，这是本游戏最后一段代码了。先是设置一个初始的时间变量<code>then</code>用于首先运行<code>main</code>函数使用。然后调用 <code>reset</code> 函数来开始新一轮游戏（如果你还记得的话，这个函数的作用是将英雄放到画面中间同时将怪物放到随机的地方以方便英雄去捉它）。</p>
<p>到此，相信你已经掌握了开发一个简单H5小游戏需要的基本功了。<a href="http://www.lostdecadegames.com/demos/simple_canvas_game/" target="_blank" rel="external">玩玩这个游戏</a>或者<a href="https://github.com/lostdecade/simple_canvas_game" target="_blank" rel="external">下载代码</a>自己研究研究吧 :)</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>原文：<a href="http://www.lostdecadegames.com/how-to-make-a-simple-html5-canvas-game/">How to make a simple HTML5 Canvas game</a></p>
</blockquote>
<p>想要快速上手HTML5 Canvas小游戏开发？下面通过一个例子来进行手把手教学。（如果你怀疑我的资历， <a href="http://www.wizardslizard.com/">A Wizard’s Lizard</a>这个游戏的半数以上开发是由我完成的）</p>]]>
    
    </summary>
    
      <category term="Canvas" scheme="http://wayou.github.io/tags/Canvas/"/>
    
      <category term="HTML5" scheme="http://wayou.github.io/tags/HTML5/"/>
    
      <category term="前端" scheme="http://wayou.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="游戏" scheme="http://wayou.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用HTML5 的Datalist 元素实现输入提示]]></title>
    <link href="http://wayou.github.io/2014/09/14/autocomplete-with-html5-datalist/"/>
    <id>http://wayou.github.io/2014/09/14/autocomplete-with-html5-datalist/</id>
    <published>2014-09-14T14:23:54.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<p>HTML5有无限可能，总是在释出一些新鲜实用的功能，让原生的web环境更加炫酷。</p>
<p>今天看到<code>datalist</code> 这个元素，可以用来预先定义一个输入框的潜在选项，也就是我们在平时项目中经常用jQuery插件或者自己写JS来实现的<code>autocomplete</code>「自动补全，但似乎自动提示更贴切一些」功能。</p>
<a id="more"></a>
<h1 id="datalist_标签">datalist 标签</h1><p>具体来说，页面上的<code>input</code>还是原来的<code>input</code>，只是在它的下面定义一下新的<code>datalist</code>在其中填充触发提示的文本,同时在该<code>input</code>元素上指定<code>list</code>属性指向这个<code>list</code>。一个大概的例子大概是像下面这样：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">你最喜欢的浏览器是： <span class="tag">&lt;<span class="title">input</span> <span class="attribute">list</span>=<span class="value">"browsers"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">datalist</span> <span class="attribute">id</span>=<span class="value">"browsers"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Internet Explorer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Firefox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Chrome"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Opera"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Safari"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>最后出来的效果又差不多是这样的：<br><img src="/asset/posts/2014-09-14-autocomplete-with-html5-datalist/datalist1.gif" alt="HTML5 datalist demo"></p>
<p>在线查看效果请点击<a href="http://sandbox.runjs.cn/show/lvgpes2k" target="_blank" rel="external">这里</a></p>
<p>没什么特别之处，简单得发指~</p>
<p>但相信大家在看了效果后跟我一样，发现了一个不足之处，在<code>input</code>右边会有向下的箭头，这让它看起来就像一个<code>dropdown</code> 或者<code>select</code> 「下拉框」，解决办法是多加两句CSS代码来将它隐藏，但此方法只是针对<code>webkit</code>内核的浏览器进行的优化：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">input</span>:<span class="value">:-webkit-calendar-picker-indicator &#123;</span><br><span class="line">    display: none</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">-webkit-appearance</span>:<span class="value"> none</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样之后出来的效果差不多成了这样：<br><img src="/asset/posts/2014-09-14-autocomplete-with-html5-datalist/datalist2.gif" alt="HTML5 datalist 去掉箭头的版本"></p>
<h1 id="浏览器兼容性">浏览器兼容性</h1><p>下面的数据来自<a href="http://caniuse.com/#feat=datalist" target="_blank" rel="external">caniuse</a>。<br><img src="/asset/posts/2014-09-14-autocomplete-with-html5-datalist/caniuse_datalist.jpg" alt="Datalist 元素兼容性"><br>可以看出，遥遥领先的依然是风采依旧的Chrome，对该元素的支持全线飘绿；<br>同时Firefox也是毫不示弱，紧随版本帝之后;<br>而其他浏览器情况则各不相同，正所谓<strong>性</strong>福的人都相似，不幸的人各有不幸。<br>Opera在边缘浏览器中表现强劲，绿得很耀眼；<br>值得注意的是，在这场不算较量的较量中，苹果太子Safari则是黑马般拿到了垫底的位置，全线飘红。这直接一举打破IE在主流浏览器的各种评测中常年垫底的记录。<br>而IE虽然摆脱了末位的阴影，但即使是最新的IE11也只是对<code>Datalist</code>元素进行了部分支持，所以要与各强劲对手比肩而受到前端开发者的青睐还有些工作要做。但留给IE翻盘的时间已经不多了，正如留给中国队的时间一样~</p>
<h1 id="REFERENCE">REFERENCE</h1><ul>
<li><a href="http://caniuse.com/#feat=datalist" target="_blank" rel="external">Can I Use Datalist element</a></li>
<li><a href="http://www.codelator.com/blog/2014/sep/how-to-create-autocomplete-textbox-using-datalist-in-html5.html" target="_blank" rel="external">How to create Autocomplete Textbox using Datalist in HTML5</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>HTML5有无限可能，总是在释出一些新鲜实用的功能，让原生的web环境更加炫酷。</p>
<p>今天看到<code>datalist</code> 这个元素，可以用来预先定义一个输入框的潜在选项，也就是我们在平时项目中经常用jQuery插件或者自己写JS来实现的<code>autocomplete</code>「自动补全，但似乎自动提示更贴切一些」功能。</p>]]>
    
    </summary>
    
      <category term="Autocomplete" scheme="http://wayou.github.io/tags/Autocomplete/"/>
    
      <category term="Datalist" scheme="http://wayou.github.io/tags/Datalist/"/>
    
      <category term="HTML5" scheme="http://wayou.github.io/tags/HTML5/"/>
    
      <category term="前端" scheme="http://wayou.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chrome 控制台不完全指南]]></title>
    <link href="http://wayou.github.io/2014/09/10/chrome-console-tips-and-tricks/"/>
    <id>http://wayou.github.io/2014/09/10/chrome-console-tips-and-tricks/</id>
    <published>2014-09-10T21:20:04.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<p>Chrome的开发者工具已经强大到没朋友的地步了，特别是其功能丰富界面友好的console，使用得当可以有如下功效：</p>
<ul>
<li>更高「逼格」更快「开发调试」更强「进阶级的Frontender」</li>
<li>Bug无处遁形「Console大法好」</li>
</ul>
<a id="more"></a>
<h2 id="console-log">console.log</h2><p>大家都会用log，但鲜有人很好地利用<code>console.error</code> , <code>console.warn</code> 等将输出到控制台的信息进行分类整理。<br>他们功能区别不大，意义在于将输出到控制台的信息进行归类，或者说让它们更语义化。<br>各个所代表的语义如下：</p>
<ul>
<li><code>console.log</code>：普通信息</li>
<li><code>console.info</code>：提示类信息</li>
<li><code>console.error</code>：错误信息</li>
<li><code>console.warn</code>：警示信息</li>
</ul>
<p>当合理使用上述log方法后，可以很方便地在控制台选择查看特定类型的信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'一颗红心向太阳'</span>,<span class="string">'吼吼~'</span>);</span><br><span class="line"><span class="built_in">console</span>.info(<span class="string">'楼上药不能停！'</span>);</span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">'楼上嘴太贱！'</span>);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'楼上关你毛事？'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/1.jpg" alt=""></p>
<p>如果再配合<code>console.group</code> 与<code>console.groupEnd</code>，可以将这种分类管理的思想发挥到极致。这适合于在开发一个规模很大模块很多很复杂的Web APP时，将各自的log信息分组到以各自命名空间为名称的组里面。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.group(<span class="string">"app.foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"来自foo模块的信息 blah blah blah..."</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">"app.bar"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"来自bar模块的信息 blah blah blah..."</span>);</span><br><span class="line"><span class="built_in">console</span>.groupEnd();</span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/2.jpg" alt=""></p>
<p>而关于<code>console.log</code>，早已被玩儿坏了。一切都源于Chrome提供了这么一个API：第一个参数可以包含一些格式化的指令比如<code>%c</code>。</p>
<p>比如给<code>hello world</code> 做件漂亮的嫁衣再拉出来见人：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%chello world'</span>,<span class="string">'font-size:25px;color:red;'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/3.jpg" alt=""></p>
<p>如果你觉得不够过瘾，那就把你能写出来的最华丽的CSS样式都应用上吧，比如渐变。于是你可以得到如下华丽丽的效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%chello world'</span>, <span class="string">'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/4.jpg" alt=""></p>
<p>各种招大招的节奏啊~</p>
<p>看着上面密集的代码不用惊慌，上面<code>console.log()</code>第二个参数全是纯CSS用来控制样式的，你不会陌生。而第一个参数里可以带用百分号开头的转义指令，如上面输出带样式的文字时使用的<code>%c</code>指令。更详细的指令参见官方API文档的<a href="https://developer.chrome.com/devtools/docs/console-api#consolelogobject-object" target="_blank" rel="external">这个表格</a>。</p>
<p>如果还不够过瘾，那咱们来log一些图片吧，甚至。。。动图？<br>对，你得先有图，我们拿<a href="http://wayou.github.io/2014/09/10/chrome-console-tips-and-tricks/rabbit.gif">这张图</a>为例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"%c"</span>, <span class="string">"padding:50px 300px;line-height:120px;background:url('http://wayou.github.io/2014/09/10/chrome-console-tips-and-tricks/rabbit.gif') no-repeat;"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/5.gif" alt=""></p>
<p>看着上面摇摆的豆比兔是不是有种抽它一脸的冲动。</p>
<p>除此，<code>console.table</code> 更是直接以表格的形式将数据输出，不能赞得太多！<br>借用之前写过的<a href="http://www.cnblogs.com/Wayou/p/things_you_dont_know_about_frontend.html" target="_blank" rel="external">一篇博文</a>里的例子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123;<span class="string">'品名'</span>: <span class="string">'杜雷斯'</span>, <span class="string">'数量'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'品名'</span>: <span class="string">'冈本'</span>, <span class="string">'数量'</span>: <span class="number">3</span>&#125;];</span><br><span class="line"><span class="built_in">console</span>.table(data);</span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/6.jpg" alt=""></p>
<p>另外，<code>console.log()</code> 接收不定参数，参数间用逗号分隔，最终会输出会将它们以空白字符连接。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%c你好'</span>,<span class="string">'color:red;'</span>,<span class="string">'小明'</span>,<span class="string">'你知道小红被妈妈打了么'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/7.jpg" alt=""></p>
<h2 id="console-assert">console.assert</h2><p>当你想代码满足某些条件时才输出信息到控制台，那么你大可不必写<code>if</code>或者三元表达式来达到目的，<code>cosole.assert</code>便是这样场景下一种很好的工具，它会先对传入的表达式进行断言，只有表达式为假时才输出相应信息到控制台。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isDebug=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.assert(isDebug,<span class="string">'开发中的log信息。。。'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/8.jpg" alt=""></p>
<h2 id="console-count">console.count</h2><p>除了条件输出的场景，还有常见的场景是计数。<br>当你想统计某段代码执行了多少次时也大可不必自己去写相关逻辑，内置的<code>console.count</code>可以很地胜任这样的任务。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//其他函数逻辑blah blah。。。</span></span><br><span class="line">	<span class="built_in">console</span>.count(<span class="string">'foo 被执行的次数：'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">foo();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/9.jpg" alt=""></p>
<h2 id="console-dir">console.dir</h2><p>将DOM结点以JavaScript对象的形式输出到控制台<br>而<code>console.log</code>是直接将该DOM结点以DOM树的结构进行输出，与在元素审查时看到的结构是一致的。不同的展现形式，同样的优雅，各种体位任君选择反正就是方便与体贴。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">document</span>.body);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/10.jpg" alt=""></p>
<h2 id="console-time_&amp;_console-timeEnd">console.time &amp; console.timeEnd</h2><p>输出一些调试信息是控制台最常用的功能，当然，它的功能远不止于此。当做一些性能测试时，同样可以在这里很方便地进行。<br>比如需要考量一段代码执行的耗时情况时，可以用<code>console.time</code>与 <code>console.timeEnd</code>来做此事。</p>
<p>这里借用官方文档的例子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"Array initialize"</span>);</span><br><span class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"Array initialize"</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/11.jpg" alt=""></p>
<p>当然，我们也可以选择自己写代码来计时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start=<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()-start);</span><br></pre></td></tr></table></figure>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/12.jpg" alt=""></p>
<p>相信你也看到了，用内置的<code>console.time</code>是多么地方便，省去了自己写代码来计算的工作量。另外值得一提的是，通过调用内置的<code>console.time</code>得到的结果要比自己手动计算的时间差更精确可靠。</p>
<h2 id="console-profile_&amp;_console-timeLime">console.profile &amp; console.timeLime</h2><p>当想要查看CPU使用相关的信息时，可以使用<code>console.profile</code>配合 <code>console.profileEnd</code>来完成这个需求。<br>这一功能可以通过UI界面来完成，Chrome 开发者工具里面有个tab便是<code>Profile</code>。</p>
<p>与此类似的功能还有<code>console.timeLine</code>配合 <code>console.timeLineEnd</code>,它的作用是开始记录一段时间轴，同样可以通过Chrome开发者工具里的<code>Timeline</code> 标签来进行相应操作。</p>
<p>所以在我看来这两个方法有点鸡肋，因为都可以通过操作界面来完成。但至少他提供了一种命令行方式的交互，还是多了种姿势供选择吧。</p>
<h2 id="console-trace">console.trace</h2><p>堆栈跟踪相关的调试可以使用<code>console.trace</code>。这个同样可以通过UI界面完成。当代码被打断点后，可以在<code>Call Stack</code>面板中查看相关堆栈信息。</p>
<p>上面介绍的都是挂在<code>window.console</code>这个对象下面的方法，统称为<a href="https://developer.chrome.com/devtools/docs/console-api" target="_blank" rel="external">Console API</a>，接下来的这些方法确切地说应该叫命令，是Chrome内置提供，在控制台中使用的，他们统称为<a href="https://developer.chrome.com/devtools/docs/commandline-api" target="_blank" rel="external">Command Line API</a>。</p>
<h2 id="$">$</h2><p>似乎美刀总是被程序员及各种编程语言所青睐「你看看PHP代码就知道PHPer有多爱钱了」，在Chrome的控制台里，$用处还真是蛮多且方便的。<br><code>$_</code>命令返回最近一次表达式执行的结果，功能跟按向上的方向键再回车是一样的，但它可以做为一个变量使用在你接下来的表达式中：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>+<span class="number">2</span><span class="comment">//回车，再</span></span><br><span class="line">$_+<span class="number">1</span><span class="comment">//回车得5</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/13.jpg" alt=""></p>
<p>上面的<code>$_</code>需要领悟其奥义才能使用得当，而$0~$4则代表了最近5个你选择过的DOM节点。<br>什么意思？在页面右击选择<code>审查元素</code>，然后在弹出来的DOM结点树上面随便点选，这些被点过的节点会被记录下来，而<code>$0</code>会返回最近一次点选的DOM结点，以此类推，$1返回的是上上次点选的DOM节点，最多保存了5个，如果不够5个，则返回<code>undefined</code>。<br><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/$0.gif" alt=""></p>
<p>另外值得一赞的是，Chrome 控制台中原生支持类jQuery的选择器，也就是说你可以用<code>$</code>加上熟悉的css选择器来选择DOM节点，多么滴熟悉。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'body'</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/14.jpg" alt=""></p>
<p>$(selector)返回的是满足选择条件的首个DOM元素。<br>剥去她伪善的外衣，其实<code>$(selector)</code>是原生JavaScript <code>document.querySelector()</code> 的封装。<br>同时另一个命令<code>$$(selector)</code>返回的是所有满足选择条件的元素的一个集合，是对<code>document.querySelectorAll()</code> 的封装。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$$(<span class="string">'div'</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/15.jpg" alt=""></p>
<h2 id="copy">copy</h2><p>通过此命令可以将在控制台获取到的内容复制到剪贴板。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">copy(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure></p>
<p>然后你就可以到处粘了：</p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/16.jpg" alt=""></p>
<p>看完此条命令行，机智的你是不是跟脑洞全开的我一样，冒出了这样一个想法：那就是通过这个命令可以在JavaScript里进行复制操作从而不用依赖Flash插件了。<br>But现实是残酷的，如之前所述的，这里的控制台命令只能在控制台中环境中执行，因为他不依附于任何全局变量比如<code>window</code>，所以其实在JS代码里是访问不了这个<code>copy</code>方法的，所以从代码层面来调用复制功能也就无从谈起。但愿有天浏览器会提供相应的JS实现吧~</p>
<h2 id="keys_&amp;_values">keys &amp; values</h2><p>这是一对基友。前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组。具体请看下面的例子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tboy=&#123;name:<span class="string">'wayou'</span>,gender:<span class="string">'unknown'</span>,hobby:<span class="string">'opposite to the gender'</span>&#125;;</span><br><span class="line">keys(tboy);</span><br><span class="line">values(tboy);</span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/17.jpg" alt=""></p>
<h2 id="monitor_&amp;_unmonitor">monitor &amp; unmonitor</h2><p>monitor(function)，它接收一个函数名作为参数，比如<code>function a</code>,每次<code>a</code>被执行了，都会在控制台输出一条信息，里面包含了函数的名称<code>a</code>及执行时所传入的参数。</p>
<p>而unmonitor(function)便是用来停止这一监听。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">'hello,'</span>+name);</span><br><span class="line">&#125;</span><br><span class="line">monitor(sayHello);</span><br><span class="line">sayHello(<span class="string">'wayou'</span>);</span><br><span class="line">unmonitor(sayHello);</span><br><span class="line">sayHello(<span class="string">'wayou'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/18.jpg" alt=""></p>
<h2 id="debug_&amp;_undebug">debug &amp; undebug</h2><p>debug同样也是接收一个函数名作为参数。当该函数执行时自动断下来以供调试，类似于在该函数的入口处打了个断点，可以通过debugger来做到，同时也可以通过在Chrome开发者工具里找到相应源码然后手动打断点。<br>而<code>undebug</code> 则是解除该断点。</p>
<p>而其他还有好些命令则让人没有说的欲望，因为好些都可以通过Chrome开发者工具的UI界面来操作并且比用在控制台输入要方便。</p>
<h2 id="REFERENCE">REFERENCE</h2><ul>
<li><a href="https://plus.google.com/+AddyOsmani/posts/TanDFKEN9Kn" target="_blank" rel="external">Styled console logging in the Chrome DevTools (Canary)</a></li>
<li><a href="https://developer.chrome.com/devtools/docs/console-api" target="_blank" rel="external">Chrome Console API</a></li>
<li><a href="https://developer.chrome.com/devtools/docs/commandline-api" target="_blank" rel="external">Chrome Console Command Line API</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Chrome的开发者工具已经强大到没朋友的地步了，特别是其功能丰富界面友好的console，使用得当可以有如下功效：</p>
<ul>
<li>更高「逼格」更快「开发调试」更强「进阶级的Frontender」</li>
<li>Bug无处遁形「Console大法好」</li>
</ul>]]>
    
    </summary>
    
      <category term="chrome" scheme="http://wayou.github.io/tags/chrome/"/>
    
      <category term="console" scheme="http://wayou.github.io/tags/console/"/>
    
      <category term="dev-tools" scheme="http://wayou.github.io/tags/dev-tools/"/>
    
      <category term="浏览器" scheme="http://wayou.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义Sublime Text的图标]]></title>
    <link href="http://wayou.github.io/2014/08/31/how-to-customize-sublime-icon/"/>
    <id>http://wayou.github.io/2014/08/31/how-to-customize-sublime-icon/</id>
    <published>2014-08-31T11:56:00.000Z</published>
    <updated>2015-07-06T11:15:41.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.sublimetext.com/3" target="_blank" rel="external">sublime text</a>很赞，windows上最接近mac逼格的轻量编辑器，对于我这样比较喜欢格调的人来说，简直不二之选啊。</p>
<p>美中不足的是，看久了觉得它的图标似乎不是很上心。现在都流行扁平化了而它还停留在拟物的阶段，拟物也就算了还带一点立体感把整个平面内顷，于是乎想自己换个图标，换个好心情。</p>
<p>如果你有同样的审美那我们继续。</p>
<a id="more"></a>
<h2 id="step1-_选择喜欢的图片">step1. 选择喜欢的图片</h2><p>首先你需要选择一个中意的图片做为新的图标，这里拿我喜欢的章鱼猫为例。<br><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/octocat.png" alt="octocat"></p>
<p>当然你不喜欢章鱼猫，随便<a href="https://www.google.com/search?q=octocat+icon&amp;newwindow=1&amp;safe=off&amp;tbm=isch&amp;imgil=wqxX4jp591NZZM%253A%253Beb8wapPIz1AUTM%253Bhttps%25253A%25252F%25252Fsupport.wombat.co%25252Fhc%25252Fen-us%25252Farticles%25252F202245250-Shipstation-Integration-&amp;source=iu&amp;fir=wqxX4jp591NZZM%253A%252Ceb8wapPIz1AUTM%252C_&amp;usg=__2FX1-Ux3h7wdDssc2u6t_4Ba7Nc%3D&amp;sa=X&amp;ei=EJ8CVI32HNjd8AXYp4KIAw&amp;ved=0CCsQ9QEwBQ&amp;biw=1366&amp;bih=683#newwindow=1&amp;q=sublime+text+icon&amp;safe=off&amp;tbm=isch&amp;facrc=_&amp;imgdii=_&amp;imgrc=NPM_JHMY3bmkdM%253A%3BavC4jPKJkwSy8M%3Bhttp%253A%252F%252Fwww.jonathanfontes.pt%252Fassets%252Fimg%252Flogo-sublime-3.png%3Bhttp%253A%252F%252Fwww.jonathanfontes.pt%252F%3B512%3B512" target="_blank" rel="external">谷歌一下</a>还是有很多正常的ST图标的，比如下面这些<br><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/sublime.png" alt="sublime"></p>
<h2 id="step2-_转为ico格式">step2. 转为ico格式</h2><p>网上找的图片大多为<code>png</code>或<code>jpg</code>格式的，这里我们需要<code>ico</code>, so 需要转换一下下。<br>同样，转<code>ico</code>格式的网站也是蛮多的，比如<a href="http://www.convertico.com/" target="_blank" rel="external">这个</a>,进去后把图片上传，完了下下来后你得到的就是一个<code>.ico</code> 格式的图片啦~</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/convert_icon.png" alt="转ico格式"></p>
<h2 id="step3-_ResEdit">step3. ResEdit</h2><p><a href="http://www.resedit.net/" target="_blank" rel="external">ResEdit</a>是一个Windows下的资源编辑器，可以直接编辑<code>exe</code>文件，更改替换其中的资源，这里我们就用它来更改<code>exe</code> 程序的图标。<br>如果你手头没有，可以点击上面的链接进入官方页面选择下载。</p>
<h2 id="step4-_用ResEdit打开SublimeText">step4. 用ResEdit打开SublimeText</h2><p>将SublimeText安装目录下的<code>sublime_text.exe</code>复制一分放到比如桌面什么的。<br>运行ResEdit, <code>File-&gt;Open Project...</code>, 打开刚才复制的<code>sublime_text.exe</code>。</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/openned.png" alt="用ResEdit打开sublime_text.exe后"></p>
<h2 id="step5-_替换图标">step5. 替换图标</h2><p>打开后差不多就像上面截图一样，你会看到左边<code>Resources</code>里第一个便是<code>Icon</code>, 在这个文件夹上面右击选择<code>Add resource...-&gt;Icon</code>,如下图</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/add_resource.png" alt="添加icon资源"></p>
<p>之后在弹出的对话框里选择<code>Create from an existing file</code></p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/choose_type.png" alt="选择从现有文件创建"></p>
<p>之后去选中我们先前准备好的<code>ico</code>文件，将其加载进来。</p>
<p>完了<code>Icon</code>文件夹下多了我们自己的icon文件，现在把原来的图标删除，右击<code>103[English (Australia)]</code> 选择<code>Remove from project</code>。</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/remove.png" alt="删除原来的图标"></p>
<p>最后点击<code>File-&gt;Save</code>。</p>
<h2 id="step_final-_替换exe">step final. 替换exe</h2><p>最后，将更改后的<code>sublime_text.exe</code>考回SublimeText安装目录下将原来的文件覆盖，当然，如果你以后可能想要恢复原来的图标的话，建议你覆盖前将原来的<code>sublime_text.exe</code>文件备份一下。</p>
<p>All done!</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/final.png" alt="octocat sublimetext"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.sublimetext.com/3">sublime text</a>很赞，windows上最接近mac逼格的轻量编辑器，对于我这样比较喜欢格调的人来说，简直不二之选啊。</p>
<p>美中不足的是，看久了觉得它的图标似乎不是很上心。现在都流行扁平化了而它还停留在拟物的阶段，拟物也就算了还带一点立体感把整个平面内顷，于是乎想自己换个图标，换个好心情。</p>
<p>如果你有同样的审美那我们继续。</p>]]>
    
    </summary>
    
      <category term="icon" scheme="http://wayou.github.io/tags/icon/"/>
    
      <category term="sublimetext" scheme="http://wayou.github.io/tags/sublimetext/"/>
    
      <category term="技巧" scheme="http://wayou.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="自定义" scheme="http://wayou.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
      <category term="未分类" scheme="http://wayou.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
</feed>