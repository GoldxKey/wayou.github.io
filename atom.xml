<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[刘哇勇的部落格]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://wayou.github.io/"/>
  <updated>2014-11-08T09:07:30.529Z</updated>
  <id>http://wayou.github.io/</id>
  
  <author>
    <name><![CDATA[wayou]]></name>
    <email><![CDATA[liuwayong@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[延迟求值-如何让Lo-Dash再提速x100?]]></title>
    <link href="http://wayou.github.io/2014/11/08/lazy-evaluation/"/>
    <id>http://wayou.github.io/2014/11/08/lazy-evaluation/</id>
    <published>2014-11-08T07:29:27.000Z</published>
    <updated>2014-11-08T09:07:23.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation" target="_blank" rel="external">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a></p>
</blockquote>
<p>我时常觉得像Lo-Dash这样优秀的库已经无法再优化了。它整合了各种<a href="https://www.youtube.com/watch?v=NthmeLEhDDM" target="_blank" rel="external">奇技淫巧</a>已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。</p>
<a id="more"></a>

<h1 id="延迟求值">延迟求值</h1>
<p>但似乎我错了-还可以让Lo-Dash有明显的提升。只需将关注点从细微的优化转移到算法上来。譬如，在一次循环中我们往往会去优化循环体：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> len = getLength();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {</div><div class="line">    operation(); <span class="comment">// &lt;- 10ms - 如何做到 9ms?!</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但针对循环体的优化往往很难，很多时候已经到极限了。相反，优化<code>getLength()</code> 函数尽量减少循环次数变得更有意义了。你想啊，这个数值越小，需要循环的<code>10ms</code>就越少。</p>
<p>这便是基于Lo-Dash实现延迟求值的大致思路。重要的是减少循环次数，而不是每次循环的时间。让我们考察下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">priceLt</span><span class="params">(x)</span> </span>{</div><div class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>{ <span class="keyword">return</span> item.price &lt; x; };</div><div class="line">}</div><div class="line"><span class="keyword">var</span> gems = [</div><div class="line">   { name: <span class="string">'Sunstone'</span>, price: <span class="number">4</span> }, { name: <span class="string">'Amethyst'</span>, price: <span class="number">15</span> },</div><div class="line">   { name: <span class="string">'Prehnite'</span>, price: <span class="number">20</span>}, { name: <span class="string">'Sugilite'</span>, price: <span class="number">7</span>  },</div><div class="line">   { name: <span class="string">'Diopside'</span>, price: <span class="number">3</span> }, { name: <span class="string">'Feldspar'</span>, price: <span class="number">13</span> },</div><div class="line">   { name: <span class="string">'Dioptase'</span>, price: <span class="number">2</span> }, { name: <span class="string">'Sapphire'</span>, price: <span class="number">20</span> }</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> chosen = _(gems).filter(priceLt(<span class="number">10</span>)).take(<span class="number">3</span>).value();</div></pre></td></tr></table></figure>

<p>我们只想取出3个价格低于10元的小球。通常情况下我们先过滤整个数据源，最后从所有小于10的元素里返回前面三个即可。</p>
<p><img src="/asset/posts/2014-11-08-lazy-evaluation/lodash-naive.gif" alt="lo-dash naive"></p>
<p>但这种做法并不优雅。它处理了全部8个数据，但其实只需要处理前端5个我们就能拿到结果了。延迟求值这种算法，着重于处理最小的数据而返回正确的结果。优化后如下图所示：</p>
<p><img src="/asset/posts/2014-11-08-lazy-evaluation/grafika.gif" alt="lo-dash naive"></p>
<p>一下子就获得了37.5%的性能提升。很容易找出提升X1000+的例子。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> phoneNumbers = [<span class="number">5554445555</span>, <span class="number">1424445656</span>, <span class="number">5554443333</span>, … ×<span class="number">99</span>,<span class="number">999</span>];</div><div class="line"></div><div class="line"><span class="comment">// 取出100个含 `55` 的号码</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains55</span><span class="params">(str)</span> </span>{</div><div class="line">    <span class="keyword">return</span> str.contains(<span class="string">"55"</span>); </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> r = _(phoneNumbers).map(<span class="built_in">String</span>).filter(contains55).take(<span class="number">100</span>);</div></pre></td></tr></table></figure>

<p>这个例子中<code>map</code>和<code>filter</code> 将遍历99,999 个元素，但很有可能我们只需处理到1，000个元素的时候就已经拿到想要的结果了。这回性能的提升就太明显了（<a href="http://jsperf.com/lazy-demo" target="_blank" rel="external">benchmark</a>）：</p>
<p><img src="/asset/posts/2014-11-08-lazy-evaluation/benchmark.jpg" alt="benchmark"></p>
<h1 id="流水线">流水线</h1>
<p>延迟求值同时带来了另一个好处，我称之为“流水线”。要旨就是不要每次运算后都创建数组，而是所有运算去用后再生成结果数组。下面用代码说话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = _(source).map(func1).map(func2).map(func3).value();</div></pre></td></tr></table></figure>

<p>上面看似优雅的写法最终执行其实会被转换成以下原始的样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [], temp1 = [], temp2 = [], temp3 = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp1[i] = func1(source[i]);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp2[i] = func2(temp1[i]);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp3[i] = func3(temp2[i]);</div><div class="line">}</div><div class="line">result = temp3;</div></pre></td></tr></table></figure>

<p>当引入了延迟求值后，代码大致就成这样的了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   result[i] = func3(func2(func1(source[i])));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>减少不必要的中间变量多少会带来性能上的提升，特别是在数据源特别巨大，内存又吃紧的情况下。</p>
<h1 id="延迟执行">延迟执行</h1>
<p>延迟求值带来的另一个好处是延迟执行。无论何时你写了段链式代码，只有在显示地调用了<code>.value()</code>后才会真正执行。这样一来，在数据源需要异步去拉取的情况下，可以保证我们处理的是最新的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wallet = _(assets).filter(ownedBy(<span class="string">'me'</span>))</div><div class="line">                      .pluck(<span class="string">'value'</span>)</div><div class="line">                      .reduce(sum);</div><div class="line"></div><div class="line">$json.get(<span class="string">"/new/assets"</span>).success(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{</div><div class="line">    assets.push.apply(assets, data); <span class="comment">// 更新数据源</span></div><div class="line">    wallet.value(); <span class="comment">// 返回的结果是最新的</span></div><div class="line">});</div></pre></td></tr></table></figure>

<p>而且这种机制在某些情况下也会提高执行效果。我们可以老早发送一个请求获取数据，然后指定一个精确的时间来执行。</p>
<h1 id="后记">后记</h1>
<p>延迟求值并且不算什么新技术。在一些库中已经在使用了，比如<a href="http://en.wikipedia.org/wiki/Language_Integrated_Query" target="_blank" rel="external">LINQ</a>,<a href="http://danieltao.com/lazy.js/" target="_blank" rel="external">Lazy.js</a>还有其他等等。那么问题来了，Lo-Dash存在的意义是啥？我想就是你仍然可以使用你熟悉的<code>Underscore</code> 接口但享受一个更高效的底层实现，不需要额外的学习成本，代码上面也不会有大的变动，只需稍加修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>原文：<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation" target="_blank" rel="external">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a></p>
</blockquote>
<p>我时常觉得像Lo-Dash这样优秀的库已经无法再优化了。它整合了各种<a href="https://www.youtube.com/watch?v=NthmeLEhDDM" target="_blank" rel="external">奇技淫巧</a>已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://wayou.github.io/tags/JavaScript/"/>
    
      <category term="性能" scheme="http://wayou.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何开发一个简单的HTML5 Canvas 小游戏]]></title>
    <link href="http://wayou.github.io/2014/11/02/how-to-make-a-simple-html5-canvas-game-zh/"/>
    <id>http://wayou.github.io/2014/11/02/how-to-make-a-simple-html5-canvas-game-zh/</id>
    <published>2014-11-02T05:14:34.000Z</published>
    <updated>2014-11-08T09:04:20.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="http://www.lostdecadegames.com/how-to-make-a-simple-html5-canvas-game/" target="_blank" rel="external">How to make a simple HTML5 Canvas game</a></p>
</blockquote>
<p>想要快速上手HTML5 Canvas小游戏开发？下面通过一个例子来进行手把手教学。（如果你怀疑我的资历， <a href="http://www.wizardslizard.com/" target="_blank" rel="external">A Wizard’s Lizard</a>这个游戏的半数以上开发是由我完成的）</p>
<a id="more"></a>

<p>我们直接来看源码里的<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/js/game.js" target="_blank" rel="external">game.js</a>,当然你也可以<a href="http://www.lostdecadegames.com/demos/simple_canvas_game/" target="_blank" rel="external">在线体验</a>一下游戏先。</p>
<h1 id="游戏截图">游戏截图</h1>
<p><img src="/asset/posts/how-to-make-a-simple-html5-canvas-game-zh/screenshot.jpg" alt="游戏截图"></p>
<h1 id="创建画布">创建画布</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create the canvas</span></div><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</div><div class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</div><div class="line">canvas.width = <span class="number">512</span>;</div><div class="line">canvas.height = <span class="number">480</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(canvas);</div></pre></td></tr></table></figure>

<p>首先我们需要创建一张<a href="https://developer.mozilla.org/en/canvas_tutorial" target="_blank" rel="external">画布</a>作为游戏的舞台。这里通过JS代码而不是直接在HTML里写一个<code>&lt;canvas&gt;</code>元素目的是要说明代码创建也是很方便的。有了画布后就可以获得它的上下文来进行绘图了。然后我们还设置了画布大小，最后将其添加到页面上。</p>
<h1 id="准备图片">准备图片</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 背景图片</span></div><div class="line"><span class="keyword">var</span> bgReady = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> bgImage = <span class="keyword">new</span> Image();</div><div class="line">bgImage.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    bgReady = <span class="literal">true</span>;</div><div class="line">};</div><div class="line">bgImage.src = <span class="string">"images/background.png"</span>;</div></pre></td></tr></table></figure>

<p>游戏嘛少不了图片的，所以我们先加载一些图片先。简便起见，这里仅创建简单的图片对象，而不是专门写一个类或者Helper来做图片加载。<code>bgReady</code>这个变量用来标识图片是否已经加载完成从而可以放心地使用了，因为如果在<a href="http://stackoverflow.com/questions/2923564/uncaught-error-index-size-err" target="_blank" rel="external">图片加载未完成情况下进行绘制是会报错</a>的。</p>
<p>整个游戏中需要用到的三张图片：<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/images/background.png" target="_blank" rel="external">背景</a>，<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/images/hero.png" target="_blank" rel="external">英雄</a>及<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/images/monster.png" target="_blank" rel="external">怪物</a>我们都用上面的方法来处理。</p>
<h1 id="游戏对象">游戏对象</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 游戏对象</span></div><div class="line"><span class="keyword">var</span> hero = {</div><div class="line">    speed: <span class="number">256</span>, <span class="comment">// 每秒移动的像素</span></div><div class="line">    x: <span class="number">0</span>,</div><div class="line">    y: <span class="number">0</span></div><div class="line">};</div><div class="line"><span class="keyword">var</span> monster = {</div><div class="line">    x: <span class="number">0</span>,</div><div class="line">    y: <span class="number">0</span></div><div class="line">};</div><div class="line"><span class="keyword">var</span> monstersCaught = <span class="number">0</span>;</div></pre></td></tr></table></figure>

<p>现在定义一些对象将在后面用到。我们的<code>英雄</code>有一个<code>speed</code>属性用来控制他每秒移动多少像素。<code>怪物</code>游戏过程中不会移动，所以只有坐标属性就够了。<code>monstersCaught</code>则用来存储怪物被捉住的次数。</p>
<h1 id="处理用户的输入">处理用户的输入</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理按键</span></div><div class="line"><span class="keyword">var</span> keysDown = {};</div><div class="line"></div><div class="line">addEventListener(<span class="string">"keydown"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>{</div><div class="line">    keysDown[e.keyCode] = <span class="literal">true</span>;</div><div class="line">}, <span class="literal">false</span>);</div><div class="line"></div><div class="line">addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>{</div><div class="line">    <span class="keyword">delete</span> keysDown[e.keyCode];</div><div class="line">}, <span class="literal">false</span>);</div></pre></td></tr></table></figure>

<p>现在开始处理用户的输入(对初次接触游戏开发的前端同学来说，这部分开始可能就需要一些脑力了)。在前端开发中，一般是用户触发了点击事件然后才去执行动画或发起异步请求之类的，但这里我们希望游戏的逻辑能够更加紧凑同时又要及时响应输入。所以我们就把用户的输入先保存下来而不是立即响应。</p>
<p>为此，我们用<code>keysDown</code>这个对象来保存用户按下的键值(<code>keyCode</code>)，如果按下的键值在这个对象里，那么我们就做相应处理。</p>
<h1 id="开始一轮游戏">开始一轮游戏</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当用户抓住一只怪物后开始新一轮游戏</span></div><div class="line"><span class="keyword">var</span> reset = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    hero.x = canvas.width / <span class="number">2</span>;</div><div class="line">    hero.y = canvas.height / <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 将新的怪物随机放置到界面上</span></div><div class="line">    monster.x = <span class="number">32</span> + (<span class="built_in">Math</span>.random() * (canvas.width - <span class="number">64</span>));</div><div class="line">    monster.y = <span class="number">32</span> + (<span class="built_in">Math</span>.random() * (canvas.height - <span class="number">64</span>));</div><div class="line">};</div></pre></td></tr></table></figure>

<p><code>reset</code>方法用于开始新一轮和游戏，在这个方法里我们将英雄放回画布中心同时将怪物放到一个随机的地方。</p>
<h1 id="更新对象">更新对象</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新游戏对象的属性</span></div><div class="line"><span class="keyword">var</span> update = <span class="function"><span class="keyword">function</span> <span class="params">(modifier)</span> </span>{</div><div class="line">    <span class="keyword">if</span> (<span class="number">38</span> <span class="keyword">in</span> keysDown) { <span class="comment">// 用户按的是↑</span></div><div class="line">        hero.y -= hero.speed * modifier;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (<span class="number">40</span> <span class="keyword">in</span> keysDown) { <span class="comment">// 用户按的是↓</span></div><div class="line">        hero.y += hero.speed * modifier;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (<span class="number">37</span> <span class="keyword">in</span> keysDown) { <span class="comment">// 用户按的是←</span></div><div class="line">        hero.x -= hero.speed * modifier;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (<span class="number">39</span> <span class="keyword">in</span> keysDown) { <span class="comment">// 用户按的是→</span></div><div class="line">        hero.x += hero.speed * modifier;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 英雄与怪物碰到了么？</span></div><div class="line">    <span class="keyword">if</span> (</div><div class="line">        hero.x &lt;= (monster.x + <span class="number">32</span>)</div><div class="line">        && monster.x &lt;= (hero.x + <span class="number">32</span>)</div><div class="line">        && hero.y &lt;= (monster.y + <span class="number">32</span>)</div><div class="line">        && monster.y &lt;= (hero.y + <span class="number">32</span>)</div><div class="line">    ) {</div><div class="line">        ++monstersCaught;</div><div class="line">        reset();</div><div class="line">    }</div><div class="line">};</div></pre></td></tr></table></figure>

<p>这就是游戏中用于更新画面的<code>update</code>函数，会被规律地重复调用。首先它负责检查用户当前按住的是中方向键，然后将英雄往相应方向移动。</p>
<p>有点费脑力的或许是这个传入的<code>modifier</code> 变量。你可以在<code>main</code> 方法里看到它的来源，但这里还是有必要详细解释一下。它是基于1开始且随时间变化的一个因子。例如1秒过去了，它的值就是1，英雄的速度将会乘以1，也就是每秒移动256像素；如果半秒钟则它的值为0.5，英雄的速度就乘以0.5也就是说这半秒内英雄以正常速度一半的速度移动。理论上说因为这个<code>update</code> 方法被调用的非常快且频繁，所以<code>modifier</code>的值会很小，但有了这一因子后，不管我们的代码跑得快慢，都能够保证英雄的移动速度是恒定的。</p>
<p>现在英雄的移动已经是基于用户的输入了，接下来该检查移动过程中所触发的事件了，也就是英雄与怪物相遇。这就是本游戏的胜利点，<code>monstersCaught</code> +1然后重新开始新一轮。</p>
<h1 id="渲染物体">渲染物体</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 画出所有物体</span></div><div class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">if</span> (bgReady) {</div><div class="line">        ctx.drawImage(bgImage, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (heroReady) {</div><div class="line">        ctx.drawImage(heroImage, hero.x, hero.y);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (monsterReady) {</div><div class="line">        ctx.drawImage(monsterImage, monster.x, monster.y);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 计分</span></div><div class="line">    ctx.fillStyle = <span class="string">"rgb(250, 250, 250)"</span>;</div><div class="line">    ctx.font = <span class="string">"24px Helvetica"</span>;</div><div class="line">    ctx.textAlign = <span class="string">"left"</span>;</div><div class="line">    ctx.textBaseline = <span class="string">"top"</span>;</div><div class="line">    ctx.fillText(<span class="string">"Monsterrs caught: "</span> + monstersCaught, <span class="number">32</span>, <span class="number">32</span>);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>之前的工作都是枯燥的，直到你把所有东西画出来之后。首先当然是<a href="https://developer.mozilla.org/en/Canvas_tutorial/Using_images" target="_blank" rel="external">把背景图画出来</a>。然后如法炮制将英雄和怪物也画出来。这个过程中的顺序是有讲究的，因为后画的物体会覆盖之前的物体。</p>
<p>这之后我们改变了一下<code>Canvas</code>的绘图上下文的样式并调用<code>fillText</code>来绘制文字，也就是记分板那一部分。本游戏没有其他复杂的动画效果和打斗场面，绘制部分大功告成！</p>
<h1 id="主循环函数">主循环函数</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 游戏主函数</span></div><div class="line"><span class="keyword">var</span> main = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</div><div class="line">    <span class="keyword">var</span> delta = now - then;</div><div class="line"></div><div class="line">    update(delta / <span class="number">1000</span>);</div><div class="line">    render();</div><div class="line"></div><div class="line">    then = now;</div><div class="line"></div><div class="line">    <span class="comment">// 立即调用主函数</span></div><div class="line">    requestAnimationFrame(main);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>上面的主函数控制了整个游戏的流程。先是拿到当前的时间用来计算时间差（距离上次主函数被调用时过了多少毫秒）。得到<code>modifier</code>后除以1000(也就是1秒中的毫秒数)再传入<code>update</code>函数。最后调用<code>render</code> 函数并且将本次的时间保存下来。</p>
<p>关于游戏中循环更新画面的讨论可参见「<a href="http://www.html5rocks.com/en/tutorials/casestudies/onslaught.html#toc-the-game-loop" target="_blank" rel="external"> Onslaught! Arena Case Study</a>」。</p>
<h1 id="关于循环的进一步解释">关于循环的进一步解释</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// requestAnimationFrame 的浏览器兼容性处理</span></div><div class="line"><span class="keyword">var</span> w = <span class="built_in">window</span>;</div><div class="line">requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;</div></pre></td></tr></table></figure>

<p><em>如果你不是完全理解上面的代码也没关系，我只是觉得拿出来解释一下总是极好的</em></p>
<p>为了循环地调用<code>main</code>函数，本游戏之前用的是<code>setInterval</code>。但现今已经有了更好的方法那就是<code>requestAnimationFrame</code>。使用新方法就不得不考虑浏览器兼容性。上面的<a href="https://en.wikipedia.org/wiki/Polyfill" target="_blank" rel="external">垫片</a>就是出于这样的考虑，它是<a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="external">Paul Irish 博客原版</a>的一个简化版本。</p>
<h1 id="启动游戏！">启动游戏！</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 少年，开始游戏吧！</span></div><div class="line"><span class="keyword">var</span> then = <span class="built_in">Date</span>.now();</div><div class="line">reset();</div><div class="line">main();</div></pre></td></tr></table></figure>

<p>总算完成了，这是本游戏最后一段代码了。先是设置一个初始的时间变量<code>then</code>用于首先运行<code>main</code>函数使用。然后调用 <code>reset</code> 函数来开始新一轮游戏（如果你还记得的话，这个函数的作用是将英雄放到画面中间同时将怪物放到随机的地方以方便英雄去捉它）。</p>
<p>到此，相信你已经掌握了开发一个简单H5小游戏需要的基本功了。<a href="http://www.lostdecadegames.com/demos/simple_canvas_game/" target="_blank" rel="external">玩玩这个游戏</a>或者<a href="https://github.com/lostdecade/simple_canvas_game" target="_blank" rel="external">下载代码</a>自己研究研究吧 :)</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>原文：<a href="http://www.lostdecadegames.com/how-to-make-a-simple-html5-canvas-game/" target="_blank" rel="external">How to make a simple HTML5 Canvas game</a></p>
</blockquote>
<p>想要快速上手HTML5 Canvas小游戏开发？下面通过一个例子来进行手把手教学。（如果你怀疑我的资历， <a href="http://www.wizardslizard.com/" target="_blank" rel="external">A Wizard’s Lizard</a>这个游戏的半数以上开发是由我完成的）</p>
]]>
    
    </summary>
    
      <category term="HTML5" scheme="http://wayou.github.io/tags/HTML5/"/>
    
      <category term="Canvas" scheme="http://wayou.github.io/tags/Canvas/"/>
    
      <category term="游戏" scheme="http://wayou.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="前端" scheme="http://wayou.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用HTML5 的Datalist 元素实现输入提示]]></title>
    <link href="http://wayou.github.io/2014/09/14/autocomplete-with-html5-datalist/"/>
    <id>http://wayou.github.io/2014/09/14/autocomplete-with-html5-datalist/</id>
    <published>2014-09-14T06:23:54.000Z</published>
    <updated>2014-11-08T09:04:31.000Z</updated>
    <content type="html"><![CDATA[<p>HTML5有无限可能，总是在释出一些新鲜实用的功能，让原生的web环境更加炫酷。</p>
<p>今天看到<code>datalist</code> 这个元素，可以用来预先定义一个输入框的潜在选项，也就是我们在平时项目中经常用jQuery插件或者自己写JS来实现的<code>autocomplete</code>「自动补全，但似乎自动提示更贴切一些」功能。</p>
<a id="more"></a>

<p>具体来说，页面上的<code>input</code>还是原来的<code>input</code>，只是在它的下面定义一下新的<code>datalist</code>在其中填充触发提示的文本,同时在该<code>input</code>元素上指定<code>list</code>属性指向这个<code>list</code>。一个大概的例子大概是像下面这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">你最喜欢的浏览器是： <span class="tag">&lt;<span class="title">input</span> <span class="attribute">list</span>=<span class="value">"browsers"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">datalist</span> <span class="attribute">id</span>=<span class="value">"browsers"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Internet Explorer"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Firefox"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Chrome"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Opera"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"Safari"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">datalist</span>&gt;</span></div></pre></td></tr></table></figure>

<p>最后出来的效果又差不多是这样的：<br><img src="/asset/posts/2014-09-14-autocomplete-with-html5-datalist/datalist1.gif" alt="HTML5 datalist demo"></p>
<p>在线查看效果请点击<a href="http://sandbox.runjs.cn/show/lvgpes2k" target="_blank" rel="external">这里</a></p>
<p>没什么特别之处，简单得发指~</p>
<p>但相信大家在看了效果后跟我一样，发现了一个不足之处，在<code>input</code>右边会有向下的箭头，这让它看起来就像一个<code>dropdown</code> 或者<code>select</code> 「下拉框」，解决办法是多加两句CSS代码来将它隐藏，但此方法只是针对<code>webkit</code>内核的浏览器进行的优化：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">input</span><span class="pseudo">::-webkit-calendar-picker-indicator</span> <span class="rules">{</span></div><div class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</div><div class="line">    <span class="rule"><span class="attribute">-webkit-appearance</span>:<span class="value"> none</span></span>;</div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<p>这样之后出来的效果差不多成了这样：<br><img src="/asset/posts/2014-09-14-autocomplete-with-html5-datalist/datalist2.gif" alt="HTML5 datalist 去掉箭头的版本"></p>
<h2 id="浏览器兼容性">浏览器兼容性</h2>
<p>下面的数据来自<a href="http://caniuse.com/#feat=datalist" target="_blank" rel="external">caniuse</a>。<br><img src="/asset/posts/2014-09-14-autocomplete-with-html5-datalist/caniuse_datalist.jpg" alt="Datalist 元素兼容性"><br>可以看出，遥遥领先的依然是风采依旧的Chrome，对该元素的支持全线飘绿；<br>同时Firefox也是毫不示弱，紧随版本帝之后;<br>而其他浏览器情况则各不相同，正所谓<strong>性</strong>福的人都相似，不幸的人各有不幸。<br>Opera在边缘浏览器中表现强劲，绿得很耀眼；<br>值得注意的是，在这场不算较量的较量中，苹果太子Safari则是黑马般拿到了垫底的位置，全线飘红。这直接一举打破IE在主流浏览器的各种评测中常年垫底的记录。<br>而IE虽然摆脱了末位的阴影，但即使是最新的IE11也只是对<code>Datalist</code>元素进行了部分支持，所以要与各强劲对手比肩而受到前端开发者的青睐还有些工作要做。但留给IE翻盘的时间已经不多了，正如留给中国队的时间一样~</p>
<h1 id="REFERENCE">REFERENCE</h1>
<ul>
<li><a href="http://caniuse.com/#feat=datalist" target="_blank" rel="external">Can I Use Datalist element</a></li>
<li><a href="http://www.codelator.com/blog/2014/sep/how-to-create-autocomplete-textbox-using-datalist-in-html5.html" target="_blank" rel="external">How to create Autocomplete Textbox using Datalist in HTML5</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>HTML5有无限可能，总是在释出一些新鲜实用的功能，让原生的web环境更加炫酷。</p>
<p>今天看到<code>datalist</code> 这个元素，可以用来预先定义一个输入框的潜在选项，也就是我们在平时项目中经常用jQuery插件或者自己写JS来实现的<code>autocomplete</code>「自动补全，但似乎自动提示更贴切一些」功能。</p>
]]>
    
    </summary>
    
      <category term="HTML5" scheme="http://wayou.github.io/tags/HTML5/"/>
    
      <category term="Datalist" scheme="http://wayou.github.io/tags/Datalist/"/>
    
      <category term="Autocomplete" scheme="http://wayou.github.io/tags/Autocomplete/"/>
    
      <category term="前端" scheme="http://wayou.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chrome 控制台不完全指南]]></title>
    <link href="http://wayou.github.io/2014/09/10/chrome-console-tips-and-tricks/"/>
    <id>http://wayou.github.io/2014/09/10/chrome-console-tips-and-tricks/</id>
    <published>2014-09-10T13:20:04.000Z</published>
    <updated>2014-11-08T09:04:48.000Z</updated>
    <content type="html"><![CDATA[<p>Chrome的开发者工具已经强大到没朋友的地步了，特别是其功能丰富界面友好的console，使用得当可以有如下功效：</p>
<ul>
<li>更高「逼格」更快「开发调试」更强「进阶级的Frontender」</li>
<li>Bug无处遁形「Console大法好」</li>
</ul>
<a id="more"></a>

<h2 id="console-log">console.log</h2>
<p>大家都会用log，但鲜有人很好地利用<code>console.error</code> , <code>console.warn</code> 等将输出到控制台的信息进行分类整理。<br>他们功能区别不大，意义在于将输出到控制台的信息进行归类，或者说让它们更语义化。<br>各个所代表的语义如下：</p>
<ul>
<li><code>console.log</code>：普通信息</li>
<li><code>console.info</code>：提示类信息</li>
<li><code>console.error</code>：错误信息</li>
<li><code>console.warn</code>：警示信息</li>
</ul>
<p>当合理使用上述log方法后，可以很方便地在控制台选择查看特定类型的信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'一颗红心向太阳'</span>,<span class="string">'吼吼~'</span>);</div><div class="line"><span class="built_in">console</span>.info(<span class="string">'楼上药不能停！'</span>);</div><div class="line"><span class="built_in">console</span>.warn(<span class="string">'楼上嘴太贱！'</span>);</div><div class="line"><span class="built_in">console</span>.error(<span class="string">'楼上关你毛事？'</span>);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/1.jpg" alt=""></p>
<p>如果再配合<code>console.group</code> 与<code>console.groupEnd</code>，可以将这种分类管理的思想发挥到极致。这适合于在开发一个规模很大模块很多很复杂的Web APP时，将各自的log信息分组到以各自命名空间为名称的组里面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.group(<span class="string">"app.foo"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"来自foo模块的信息 blah blah blah..."</span>);</div><div class="line"><span class="built_in">console</span>.groupEnd();</div><div class="line"><span class="built_in">console</span>.group(<span class="string">"app.bar"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"来自bar模块的信息 blah blah blah..."</span>);</div><div class="line"><span class="built_in">console</span>.groupEnd();</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/2.jpg" alt=""></p>
<p>而关于<code>console.log</code>，早已被玩儿坏了。一切都源于Chrome提供了这么一个API：第一个参数可以包含一些格式化的指令比如<code>%c</code>。</p>
<p>比如给<code>hello world</code> 做件漂亮的嫁衣再拉出来见人：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'%chello world'</span>,<span class="string">'font-size:25px;color:red;'</span>);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/3.jpg" alt=""></p>
<p>如果你觉得不够过瘾，那就把你能写出来的最华丽的CSS样式都应用上吧，比如渐变。于是你可以得到如下华丽丽的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'%chello world'</span>, <span class="string">'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;'</span>);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/4.jpg" alt=""></p>
<p>各种招大招的节奏啊~</p>
<p>看着上面密集的代码不用惊慌，上面<code>console.log()</code>第二个参数全是纯CSS用来控制样式的，你不会陌生。而第一个参数里可以带用百分号开头的转义指令，如上面输出带样式的文字时使用的<code>%c</code>指令。更详细的指令参见官方API文档的<a href="https://developer.chrome.com/devtools/docs/console-api#consolelogobject-object" target="_blank" rel="external">这个表格</a>。</p>
<p>如果还不够过瘾，那咱们来log一些图片吧，甚至。。。动图？<br>对，你得先有图，我们拿<a href="http://wayou.github.io/2014/09/10/chrome-console-tips-and-tricks/rabbit.gif" target="_blank" rel="external">这张图</a>为例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"%c"</span>, <span class="string">"padding:50px 300px;line-height:120px;background:url('http://wayou.github.io/2014/09/10/chrome-console-tips-and-tricks/rabbit.gif') no-repeat;"</span>);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/5.gif" alt=""></p>
<p>看着上面摇摆的豆比兔是不是有种抽它一脸的冲动。</p>
<p>除此，<code>console.table</code> 更是直接以表格的形式将数据输出，不能赞得太多！<br>借用之前写过的<a href="http://www.cnblogs.com/Wayou/p/things_you_dont_know_about_frontend.html" target="_blank" rel="external">一篇博文</a>里的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [{<span class="string">'品名'</span>: <span class="string">'杜雷斯'</span>, <span class="string">'数量'</span>: <span class="number">4</span>}, {<span class="string">'品名'</span>: <span class="string">'冈本'</span>, <span class="string">'数量'</span>: <span class="number">3</span>}];</div><div class="line"><span class="built_in">console</span>.table(data);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/6.jpg" alt=""></p>
<p>另外，<code>console.log()</code> 接收不定参数，参数间用逗号分隔，最终会输出会将它们以空白字符连接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'%c你好'</span>,<span class="string">'color:red;'</span>,<span class="string">'小明'</span>,<span class="string">'你知道小红被妈妈打了么'</span>);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/7.jpg" alt=""></p>
<h2 id="console-assert">console.assert</h2>
<p>当你想代码满足某些条件时才输出信息到控制台，那么你大可不必写<code>if</code>或者三元表达式来达到目的，<code>cosole.assert</code>便是这样场景下一种很好的工具，它会先对传入的表达式进行断言，只有表达式为假时才输出相应信息到控制台。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isDebug=<span class="literal">false</span>;</div><div class="line"><span class="built_in">console</span>.assert(isDebug,<span class="string">'开发中的log信息。。。'</span>);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/8.jpg" alt=""></p>
<h2 id="console-count">console.count</h2>
<p>除了条件输出的场景，还有常见的场景是计数。<br>当你想统计某段代码执行了多少次时也大可不必自己去写相关逻辑，内置的<code>console.count</code>可以很地胜任这样的任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>{</div><div class="line">	<span class="comment">//其他函数逻辑blah blah。。。</span></div><div class="line">	<span class="built_in">console</span>.count(<span class="string">'foo 被执行的次数：'</span>);</div><div class="line">}</div><div class="line">foo();</div><div class="line">foo();</div><div class="line">foo();</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/9.jpg" alt=""></p>
<h2 id="console-dir">console.dir</h2>
<p>将DOM结点以JavaScript对象的形式输出到控制台<br>而<code>console.log</code>是直接将该DOM结点以DOM树的结构进行输出，与在元素审查时看到的结构是一致的。不同的展现形式，同样的优雅，各种体位任君选择反正就是方便与体贴。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.dir(<span class="built_in">document</span>.body);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/10.jpg" alt=""></p>
<h2 id="console-time_&amp;_console-timeEnd">console.time &amp; console.timeEnd</h2>
<p>输出一些调试信息是控制台最常用的功能，当然，它的功能远不止于此。当做一些性能测试时，同样可以在这里很方便地进行。<br>比如需要考量一段代码执行的耗时情况时，可以用<code>console.time</code>与 <code>console.timeEnd</code>来做此事。</p>
<p>这里借用官方文档的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time(<span class="string">"Array initialize"</span>);</div><div class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</div><div class="line">    array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">};</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"Array initialize"</span>);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/11.jpg" alt=""></p>
<p>当然，我们也可以选择自己写代码来计时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> start=<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</div><div class="line">    array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">};</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()-start);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/12.jpg" alt=""></p>
<p>相信你也看到了，用内置的<code>console.time</code>是多么地方便，省去了自己写代码来计算的工作量。另外值得一提的是，通过调用内置的<code>console.time</code>得到的结果要比自己手动计算的时间差更精确可靠。</p>
<h2 id="console-profile_&amp;_console-timeLime">console.profile &amp; console.timeLime</h2>
<p>当想要查看CPU使用相关的信息时，可以使用<code>console.profile</code>配合 <code>console.profileEnd</code>来完成这个需求。<br>这一功能可以通过UI界面来完成，Chrome 开发者工具里面有个tab便是<code>Profile</code>。</p>
<p>与此类似的功能还有<code>console.timeLine</code>配合 <code>console.timeLineEnd</code>,它的作用是开始记录一段时间轴，同样可以通过Chrome开发者工具里的<code>Timeline</code> 标签来进行相应操作。</p>
<p>所以在我看来这两个方法有点鸡肋，因为都可以通过操作界面来完成。但至少他提供了一种命令行方式的交互，还是多了种姿势供选择吧。</p>
<h2 id="console-trace">console.trace</h2>
<p>堆栈跟踪相关的调试可以使用<code>console.trace</code>。这个同样可以通过UI界面完成。当代码被打断点后，可以在<code>Call Stack</code>面板中查看相关堆栈信息。</p>
<p>上面介绍的都是挂在<code>window.console</code>这个对象下面的方法，统称为<a href="https://developer.chrome.com/devtools/docs/console-api" target="_blank" rel="external">Console API</a>，接下来的这些方法确切地说应该叫命令，是Chrome内置提供，在控制台中使用的，他们统称为<a href="https://developer.chrome.com/devtools/docs/commandline-api" target="_blank" rel="external">Command Line API</a>。</p>
<h2 id="$">$</h2>
<p>似乎美刀总是被程序员及各种编程语言所青睐「你看看PHP代码就知道PHPer有多爱钱了」，在Chrome的控制台里，$用处还真是蛮多且方便的。<br><code>$_</code>命令返回最近一次表达式执行的结果，功能跟按向上的方向键再回车是一样的，但它可以做为一个变量使用在你接下来的表达式中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>+<span class="number">2</span><span class="comment">//回车，再</span></div><div class="line">$_+<span class="number">1</span><span class="comment">//回车得5</span></div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/13.jpg" alt=""></p>
<p>上面的<code>$_</code>需要领悟其奥义才能使用得当，而$0~$4则代表了最近5个你选择过的DOM节点。<br>什么意思？在页面右击选择<code>审查元素</code>，然后在弹出来的DOM结点树上面随便点选，这些被点过的节点会被记录下来，而<code>$0</code>会返回最近一次点选的DOM结点，以此类推，$1返回的是上上次点选的DOM节点，最多保存了5个，如果不够5个，则返回<code>undefined</code>。<br><img src="$0.gif" alt=""></p>
<p>另外值得一赞的是，Chrome 控制台中原生支持类jQuery的选择器，也就是说你可以用<code>$</code>加上熟悉的css选择器来选择DOM节点，多么滴熟悉。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'body'</span>)</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/14.jpg" alt=""></p>
<p>$(selector)返回的是满足选择条件的首个DOM元素。<br>剥去她伪善的外衣，其实<code>$(selector)</code>是原生JavaScript <code>document.querySelector()</code> 的封装。<br>同时另一个命令<code>$$(selector)</code>返回的是所有满足选择条件的元素的一个集合，是对<code>document.querySelectorAll()</code> 的封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$(<span class="string">'div'</span>)</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/15.jpg" alt=""></p>
<h2 id="copy">copy</h2>
<p>通过此命令可以将在控制台获取到的内容复制到剪贴板。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">copy(<span class="built_in">document</span>.body)</div></pre></td></tr></table></figure>

<p>然后你就可以到处粘了：</p>
<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/16.jpg" alt=""></p>
<p>看完此条命令行，机智的你是不是跟脑洞全开的我一样，冒出了这样一个想法：那就是通过这个命令可以在JavaScript里进行复制操作从而不用依赖Flash插件了。<br>But现实是残酷的，如之前所述的，这里的控制台命令只能在控制台中环境中执行，因为他不依附于任何全局变量比如<code>window</code>，所以其实在JS代码里是访问不了这个<code>copy</code>方法的，所以从代码层面来调用复制功能也就无从谈起。但愿有天浏览器会提供相应的JS实现吧~</p>
<h2 id="keys_&amp;_values">keys &amp; values</h2>
<p>这是一对基友。前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组。具体请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tboy={name:<span class="string">'wayou'</span>,gender:<span class="string">'unknown'</span>,hobby:<span class="string">'opposite to the gender'</span>};</div><div class="line">keys(tboy);</div><div class="line">values(tboy);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/17.jpg" alt=""></p>
<h2 id="monitor_&amp;_unmonitor">monitor &amp; unmonitor</h2>
<p>monitor(function)，它接收一个函数名作为参数，比如<code>function a</code>,每次<code>a</code>被执行了，都会在控制台输出一条信息，里面包含了函数的名称<code>a</code>及执行时所传入的参数。</p>
<p>而unmonitor(function)便是用来停止这一监听。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">(name)</span></span>{</div><div class="line">	alert(<span class="string">'hello,'</span>+name);</div><div class="line">}</div><div class="line">monitor(sayHello);</div><div class="line">sayHello(<span class="string">'wayou'</span>);</div><div class="line">unmonitor(sayHello);</div><div class="line">sayHello(<span class="string">'wayou'</span>);</div></pre></td></tr></table></figure>

<p><img src="/asset/posts/2014-09-10-chrome-console-tips-and-tricks/18.jpg" alt=""></p>
<h2 id="debug_&amp;_undebug">debug &amp; undebug</h2>
<p>debug同样也是接收一个函数名作为参数。当该函数执行时自动断下来以供调试，类似于在该函数的入口处打了个断点，可以通过debugger来做到，同时也可以通过在Chrome开发者工具里找到相应源码然后手动打断点。<br>而<code>undebug</code> 则是解除该断点。</p>
<p>而其他还有好些命令则让人没有说的欲望，因为好些都可以通过Chrome开发者工具的UI界面来操作并且比用在控制台输入要方便。</p>
<h2 id="REFERENCE">REFERENCE</h2>
<ul>
<li><a href="https://plus.google.com/+AddyOsmani/posts/TanDFKEN9Kn" target="_blank" rel="external">Styled console logging in the Chrome DevTools (Canary)</a></li>
<li><a href="https://developer.chrome.com/devtools/docs/console-api" target="_blank" rel="external">Chrome Console API</a></li>
<li><a href="https://developer.chrome.com/devtools/docs/commandline-api" target="_blank" rel="external">Chrome Console Command Line API</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Chrome的开发者工具已经强大到没朋友的地步了，特别是其功能丰富界面友好的console，使用得当可以有如下功效：</p>
<ul>
<li>更高「逼格」更快「开发调试」更强「进阶级的Frontender」</li>
<li>Bug无处遁形「Console大法好」</li>
</ul>
]]>
    
    </summary>
    
      <category term="chrome" scheme="http://wayou.github.io/tags/chrome/"/>
    
      <category term="console" scheme="http://wayou.github.io/tags/console/"/>
    
      <category term="dev-tools" scheme="http://wayou.github.io/tags/dev-tools/"/>
    
      <category term="浏览器" scheme="http://wayou.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="技术" scheme="http://wayou.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义Sublime Text的图标]]></title>
    <link href="http://wayou.github.io/2014/08/31/how-to-customize-sublime-icon/"/>
    <id>http://wayou.github.io/2014/08/31/how-to-customize-sublime-icon/</id>
    <published>2014-08-31T03:56:00.000Z</published>
    <updated>2014-11-08T09:04:54.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.sublimetext.com/3" target="_blank" rel="external">sublime text</a>很赞，windows上最接近mac逼格的轻量编辑器，对于我这样比较喜欢格调的人来说，简直不二之选啊。</p>
<p>美中不足的是，看久了觉得它的图标似乎不是很上心。现在都流行扁平化了而它还停留在拟物的阶段，拟物也就算了还带一点立体感把整个平面内顷，于是乎想自己换个图标，换个好心情。</p>
<p>如果你有同样的审美那我们继续。</p>
<a id="more"></a>

<h2 id="step1-_选择喜欢的图片">step1. 选择喜欢的图片</h2>
<p>首先你需要选择一个中意的图片做为新的图标，这里拿我喜欢的章鱼猫为例。<br><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/octocat.png" alt="octocat"></p>
<p>当然你不喜欢章鱼猫，随便<a href="https://www.google.com/search?q=octocat+icon&amp;newwindow=1&amp;safe=off&amp;tbm=isch&amp;imgil=wqxX4jp591NZZM%253A%253Beb8wapPIz1AUTM%253Bhttps%25253A%25252F%25252Fsupport.wombat.co%25252Fhc%25252Fen-us%25252Farticles%25252F202245250-Shipstation-Integration-&amp;source=iu&amp;fir=wqxX4jp591NZZM%253A%252Ceb8wapPIz1AUTM%252C_&amp;usg=__2FX1-Ux3h7wdDssc2u6t_4Ba7Nc%3D&amp;sa=X&amp;ei=EJ8CVI32HNjd8AXYp4KIAw&amp;ved=0CCsQ9QEwBQ&amp;biw=1366&amp;bih=683#newwindow=1&amp;q=sublime+text+icon&amp;safe=off&amp;tbm=isch&amp;facrc=_&amp;imgdii=_&amp;imgrc=NPM_JHMY3bmkdM%253A%3BavC4jPKJkwSy8M%3Bhttp%253A%252F%252Fwww.jonathanfontes.pt%252Fassets%252Fimg%252Flogo-sublime-3.png%3Bhttp%253A%252F%252Fwww.jonathanfontes.pt%252F%3B512%3B512" target="_blank" rel="external">谷歌一下</a>还是有很多正常的ST图标的，比如下面这些<br><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/sublime.png" alt="sublime"></p>
<h2 id="step2-_转为ico格式">step2. 转为ico格式</h2>
<p>网上找的图片大多为<code>png</code>或<code>jpg</code>格式的，这里我们需要<code>ico</code>, so 需要转换一下下。<br>同样，转<code>ico</code>格式的网站也是蛮多的，比如<a href="http://www.convertico.com/" target="_blank" rel="external">这个</a>,进去后把图片上传，完了下下来后你得到的就是一个<code>.ico</code> 格式的图片啦~</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/convert_icon.png" alt="转ico格式"></p>
<h2 id="step3-_ResEdit">step3. ResEdit</h2>
<p><a href="http://www.resedit.net/" target="_blank" rel="external">ResEdit</a>是一个Windows下的资源编辑器，可以直接编辑<code>exe</code>文件，更改替换其中的资源，这里我们就用它来更改<code>exe</code> 程序的图标。<br>如果你手头没有，可以点击上面的链接进入官方页面选择下载。</p>
<h2 id="step4-_用ResEdit打开SublimeText">step4. 用ResEdit打开SublimeText</h2>
<p>将SublimeText安装目录下的<code>sublime_text.exe</code>复制一分放到比如桌面什么的。<br>运行ResEdit, <code>File-&gt;Open Project...</code>, 打开刚才复制的<code>sublime_text.exe</code>。</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/openned.png" alt="用ResEdit打开sublime_text.exe后"></p>
<h2 id="step5-_替换图标">step5. 替换图标</h2>
<p>打开后差不多就像上面截图一样，你会看到左边<code>Resources</code>里第一个便是<code>Icon</code>, 在这个文件夹上面右击选择<code>Add resource...-&gt;Icon</code>,如下图</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/add_resource.png" alt="添加icon资源"></p>
<p>之后在弹出的对话框里选择<code>Create from an existing file</code></p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/choose_type.png" alt="选择从现有文件创建"></p>
<p>之后去选中我们先前准备好的<code>ico</code>文件，将其加载进来。</p>
<p>完了<code>Icon</code>文件夹下多了我们自己的icon文件，现在把原来的图标删除，右击<code>103[English (Australia)]</code> 选择<code>Remove from project</code>。</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/remove.png" alt="删除原来的图标"></p>
<p>最后点击<code>File-&gt;Save</code>。</p>
<h2 id="step_final-_替换exe">step final. 替换exe</h2>
<p>最后，将更改后的<code>sublime_text.exe</code>考回SublimeText安装目录下将原来的文件覆盖，当然，如果你以后可能想要恢复原来的图标的话，建议你覆盖前将原来的<code>sublime_text.exe</code>文件备份一下。</p>
<p>All done!</p>
<p><img src="/asset/posts/2014-08-31-how-to-customize-sublime-icon/final.png" alt="octocat sublimetext"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.sublimetext.com/3" target="_blank" rel="external">sublime text</a>很赞，windows上最接近mac逼格的轻量编辑器，对于我这样比较喜欢格调的人来说，简直不二之选啊。</p>
<p>美中不足的是，看久了觉得它的图标似乎不是很上心。现在都流行扁平化了而它还停留在拟物的阶段，拟物也就算了还带一点立体感把整个平面内顷，于是乎想自己换个图标，换个好心情。</p>
<p>如果你有同样的审美那我们继续。</p>
]]>
    
    </summary>
    
      <category term="技巧" scheme="http://wayou.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="sublimetext" scheme="http://wayou.github.io/tags/sublimetext/"/>
    
      <category term="自定义" scheme="http://wayou.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
      <category term="icon" scheme="http://wayou.github.io/tags/icon/"/>
    
      <category term="瞎折腾" scheme="http://wayou.github.io/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
</feed>
